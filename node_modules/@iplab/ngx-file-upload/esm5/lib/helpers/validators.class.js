/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { IsNullOrEmpty } from './helpers.class';
import { FileUploadTypes } from './file-types.class';
/**
 * @record
 */
export function ValidationErrors() { }
/**
 * @record
 */
export function ValidatorFn() { }
/**
 * function used to check file size
 * @type {?}
 */
var checkFileSize = (/**
 * @param {?} file
 * @param {?} maxSize
 * @param {?=} minSize
 * @return {?}
 */
function (file, maxSize, minSize) {
    if (minSize === void 0) { minSize = 0; }
    return (!IsNullOrEmpty(maxSize) && file.size > maxSize) || file.size < minSize ?
        { maxSize: maxSize, minSize: minSize, actual: file.size, file: file } : null;
});
var ɵ0 = checkFileSize;
/** @type {?} */
var getFileType = (/**
 * @param {?} file
 * @param {?} fileExtension
 * @return {?}
 */
function (file, fileExtension) {
    /** @type {?} */
    var type = file.type;
    if (!IsNullOrEmpty(type)) {
        return (/** @type {?} */ (type));
    }
    return FileUploadTypes[fileExtension];
});
var ɵ1 = getFileType;
/** @type {?} */
var FILE_EXT_REG = /(^[.]\w*)$/m;
/**
 * function used to check file type
 *
 * #### allowedTypes
 * file_extension|audio/*|video/*|image/*|media_type
 * @type {?}
 */
var checkFileType = (/**
 * @param {?} file
 * @param {?} allowedTypes
 * @return {?}
 */
function (file, allowedTypes) {
    var e_1, _a;
    /** @type {?} */
    var fileExtension = file.name.split('.').pop().toLowerCase();
    /** @type {?} */
    var fileType = getFileType(file, fileExtension);
    try {
        for (var allowedTypes_1 = tslib_1.__values(allowedTypes), allowedTypes_1_1 = allowedTypes_1.next(); !allowedTypes_1_1.done; allowedTypes_1_1 = allowedTypes_1.next()) {
            var type = allowedTypes_1_1.value;
            /** @type {?} */
            var isValid = FILE_EXT_REG.test(type) ? type === "." + fileExtension : new RegExp(type).test(fileType);
            if (isValid) {
                return null;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (allowedTypes_1_1 && !allowedTypes_1_1.done && (_a = allowedTypes_1.return)) _a.call(allowedTypes_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return { allowedTypes: allowedTypes, actual: file.type, file: file };
});
var ɵ2 = checkFileType;
/** @type {?} */
var checkValueType = (/**
 * @param {?} value
 * @return {?}
 */
function (value) {
    if (!Array.isArray(value)) {
        throw Error("FormControl.setValue was provided with wrong argument type, " + value + " was provided instead Array<File>");
    }
});
var ɵ3 = checkValueType;
// @dynamic
var 
// @dynamic
FileUploadValidators = /** @class */ (function () {
    function FileUploadValidators() {
    }
    /**
     * Validator that requires controls to have a file maximum size length.
     * Compare the File size in bytes
     * @dynamic
     */
    /**
     * Validator that requires controls to have a file maximum size length.
     * Compare the File size in bytes
     * \@dynamic
     * @param {?} maxSize
     * @return {?}
     */
    FileUploadValidators.fileSize = /**
     * Validator that requires controls to have a file maximum size length.
     * Compare the File size in bytes
     * \@dynamic
     * @param {?} maxSize
     * @return {?}
     */
    function (maxSize) {
        return (/**
         * @param {?} control
         * @return {?}
         */
        function (control) {
            /** @type {?} */
            var files = control.value;
            if (IsNullOrEmpty(files)) {
                return null;
            }
            checkValueType(files);
            /** @type {?} */
            var toLargeFiles = files.map((/**
             * @param {?} file
             * @return {?}
             */
            function (file) { return checkFileSize(file, maxSize); }))
                .filter((/**
             * @param {?} error
             * @return {?}
             */
            function (error) { return error; }));
            return toLargeFiles.length > 0 ?
                { 'fileSize': toLargeFiles } : null;
        });
    };
    /**
     * Compare the File size in bytes with max and min size limits
     * @dynamic
     */
    /**
     * Compare the File size in bytes with max and min size limits
     * \@dynamic
     * @param {?} __0
     * @return {?}
     */
    FileUploadValidators.sizeRange = /**
     * Compare the File size in bytes with max and min size limits
     * \@dynamic
     * @param {?} __0
     * @return {?}
     */
    function (_a) {
        var minSize = _a.minSize, maxSize = _a.maxSize;
        return (/**
         * @param {?} control
         * @return {?}
         */
        function (control) {
            /** @type {?} */
            var files = control.value;
            if (IsNullOrEmpty(files)) {
                return null;
            }
            checkValueType(files);
            /** @type {?} */
            var sizeMismatch = files.map((/**
             * @param {?} file
             * @return {?}
             */
            function (file) { return checkFileSize(file, maxSize, minSize); }))
                .filter((/**
             * @param {?} error
             * @return {?}
             */
            function (error) { return error; }));
            return sizeMismatch.length > 0 ?
                { 'sizeRange': sizeMismatch } : null;
        });
    };
    /**
     * validator that requires control to have limit on files number
     * @dynamic
     */
    /**
     * validator that requires control to have limit on files number
     * \@dynamic
     * @param {?} numFiles
     * @return {?}
     */
    FileUploadValidators.filesLimit = /**
     * validator that requires control to have limit on files number
     * \@dynamic
     * @param {?} numFiles
     * @return {?}
     */
    function (numFiles) {
        return (/**
         * @param {?} control
         * @return {?}
         */
        function (control) {
            /** @type {?} */
            var files = control.value;
            if (IsNullOrEmpty(files)) {
                return null;
            }
            checkValueType(files);
            return files.length > numFiles ?
                { 'filesLimit': { 'max': numFiles, 'actual': files.length } } : null;
        });
    };
    /**
     * validator that requires control to have limit on media types
     *
     * ##### Allowed media types are
     *
     * - file_extension - a file extension starting with the STOP character,
     * e.g: .gif, .jpg, .png, .doc
     * - audio/* -        All sound files are accepted
     * - video/* -        All video files are accepted
     * - image/* -        All image files are accepted
     * - media_type -     A valid media type, with no parameters. Look at [IANA Media Types](https://www.iana.org/assignments/media-types/media-types.xhtml) for a complete list of standard media types
     *
     * #### Example
     * `FileUploadValidators.accept([file_extension, audio/*, video/*, image/*, media_type])`
     * @dynamic
     */
    /**
     * validator that requires control to have limit on media types
     *
     * ##### Allowed media types are
     *
     * - file_extension - a file extension starting with the STOP character,
     * e.g: .gif, .jpg, .png, .doc
     * - audio/* -        All sound files are accepted
     * - video/* -        All video files are accepted
     * - image/* -        All image files are accepted
     * - media_type -     A valid media type, with no parameters. Look at [IANA Media Types](https://www.iana.org/assignments/media-types/media-types.xhtml) for a complete list of standard media types
     *
     * #### Example
     * `FileUploadValidators.accept([file_extension, audio/*, video/*, image/*, media_type])`
     * \@dynamic
     * @param {?} allowedFileTypes
     * @return {?}
     */
    FileUploadValidators.accept = /**
     * validator that requires control to have limit on media types
     *
     * ##### Allowed media types are
     *
     * - file_extension - a file extension starting with the STOP character,
     * e.g: .gif, .jpg, .png, .doc
     * - audio/* -        All sound files are accepted
     * - video/* -        All video files are accepted
     * - image/* -        All image files are accepted
     * - media_type -     A valid media type, with no parameters. Look at [IANA Media Types](https://www.iana.org/assignments/media-types/media-types.xhtml) for a complete list of standard media types
     *
     * #### Example
     * `FileUploadValidators.accept([file_extension, audio/*, video/*, image/*, media_type])`
     * \@dynamic
     * @param {?} allowedFileTypes
     * @return {?}
     */
    function (allowedFileTypes) {
        return (/**
         * @param {?} control
         * @return {?}
         */
        function (control) {
            /** @type {?} */
            var files = control.value;
            if (IsNullOrEmpty(files)) {
                return null;
            }
            checkValueType(files);
            /** @type {?} */
            var notAllowedFiles = files.map((/**
             * @param {?} file
             * @return {?}
             */
            function (file) { return checkFileType(file, allowedFileTypes); }))
                .filter((/**
             * @param {?} error
             * @return {?}
             */
            function (error) { return error; }));
            return notAllowedFiles.length > 0 ?
                { 'fileTypes': notAllowedFiles } : null;
        });
    };
    return FileUploadValidators;
}());
// @dynamic
export { FileUploadValidators };
export { ɵ0, ɵ1, ɵ2, ɵ3 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdG9ycy5jbGFzcy5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BpcGxhYi9uZ3gtZmlsZS11cGxvYWQvIiwic291cmNlcyI6WyJsaWIvaGVscGVycy92YWxpZGF0b3JzLmNsYXNzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQ0EsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRWhELE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQzs7OztBQUVyRCxzQ0FFQzs7OztBQUVELGlDQUVDOzs7OztJQUtLLGFBQWE7Ozs7OztBQUFHLFVBQUMsSUFBVSxFQUFFLE9BQWUsRUFBRSxPQUFtQjtJQUFuQix3QkFBQSxFQUFBLFdBQW1CO0lBQ25FLE9BQU8sQ0FBQyxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLEdBQUcsT0FBTyxDQUFDLENBQUM7UUFDNUUsRUFBQyxPQUFPLFNBQUEsRUFBRSxPQUFPLFNBQUEsRUFBRSxNQUFNLEVBQUUsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLE1BQUEsRUFBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7QUFDM0QsQ0FBQyxDQUFBOzs7SUFFSyxXQUFXOzs7OztBQUFHLFVBQUMsSUFBVSxFQUFFLGFBQXFCOztRQUM1QyxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUk7SUFDdEIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsRUFBRTtRQUN0QixPQUFPLG1CQUFBLElBQUksRUFBbUIsQ0FBQztLQUNsQztJQUVELE9BQU8sZUFBZSxDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBQzFDLENBQUMsQ0FBQTs7O0lBRUssWUFBWSxHQUFHLGFBQWE7Ozs7Ozs7O0lBTzVCLGFBQWE7Ozs7O0FBQUcsVUFBQyxJQUFVLEVBQUUsWUFBMkI7OztRQUNwRCxhQUFhLEdBQUcsSUFBSSxDQUFDLElB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ZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xyXG5pbXBvcnQgeyBJc051bGxPckVtcHR5IH0gZnJvbSAnLi9oZWxwZXJzLmNsYXNzJztcclxuaW1wb3J0IHsgRmlsZVVwbG9hZENvbnRyb2wgfSBmcm9tICcuL2NvbnRyb2wuY2xhc3MnO1xyXG5pbXBvcnQgeyBGaWxlVXBsb2FkVHlwZXMgfSBmcm9tICcuL2ZpbGUtdHlwZXMuY2xhc3MnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBWYWxpZGF0aW9uRXJyb3JzIHtcclxuICAgIFtrZXk6IHN0cmluZ106IGFueTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBWYWxpZGF0b3JGbiB7XHJcbiAgICAoYzogQWJzdHJhY3RDb250cm9sIHwgRmlsZVVwbG9hZENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIGZ1bmN0aW9uIHVzZWQgdG8gY2hlY2sgZmlsZSBzaXplXHJcbiAqL1xyXG5jb25zdCBjaGVja0ZpbGVTaXplID0gKGZpbGU6IEZpbGUsIG1heFNpemU6IG51bWJlciwgbWluU2l6ZTogbnVtYmVyID0gMCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+IHtcclxuICAgIHJldHVybiAoIUlzTnVsbE9yRW1wdHkobWF4U2l6ZSkgJiYgZmlsZS5zaXplID4gbWF4U2l6ZSkgfHwgZmlsZS5zaXplIDwgbWluU2l6ZSA/XHJcbiAgICAgICAge21heFNpemUsIG1pblNpemUsIGFjdHVhbDogZmlsZS5zaXplLCBmaWxlfSA6IG51bGw7XHJcbn07XHJcblxyXG5jb25zdCBnZXRGaWxlVHlwZSA9IChmaWxlOiBGaWxlLCBmaWxlRXh0ZW5zaW9uOiBzdHJpbmcpOiBGaWxlVXBsb2FkVHlwZXMgPT4ge1xyXG4gICAgY29uc3QgdHlwZSA9IGZpbGUudHlwZTtcclxuICAgIGlmICghSXNOdWxsT3JFbXB0eSh0eXBlKSkge1xyXG4gICAgICAgIHJldHVybiB0eXBlIGFzIEZpbGVVcGxvYWRUeXBlcztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gRmlsZVVwbG9hZFR5cGVzW2ZpbGVFeHRlbnNpb25dO1xyXG59O1xyXG5cclxuY29uc3QgRklMRV9FWFRfUkVHID0gLyheWy5dXFx3KikkL207XHJcbi8qKlxyXG4gKiBmdW5jdGlvbiB1c2VkIHRvIGNoZWNrIGZpbGUgdHlwZVxyXG4gKlxyXG4gKiAjIyMjIGFsbG93ZWRUeXBlc1xyXG4gKiBmaWxlX2V4dGVuc2lvbnxhdWRpby8qfHZpZGVvLyp8aW1hZ2UvKnxtZWRpYV90eXBlXHJcbiAqL1xyXG5jb25zdCBjaGVja0ZpbGVUeXBlID0gKGZpbGU6IEZpbGUsIGFsbG93ZWRUeXBlczogQXJyYXk8c3RyaW5nPik6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+IHtcclxuICAgIGNvbnN0IGZpbGVFeHRlbnNpb24gPSBmaWxlLm5hbWUuc3BsaXQoJy4nKS5wb3AoKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgY29uc3QgZmlsZVR5cGUgPSBnZXRGaWxlVHlwZShmaWxlLCBmaWxlRXh0ZW5zaW9uKTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgYWxsb3dlZFR5cGVzICkge1xyXG4gICAgICAgIGNvbnN0IGlzVmFsaWQgPSBGSUxFX0VYVF9SRUcudGVzdCh0eXBlKSA/IHR5cGUgPT09IGAuJHtmaWxlRXh0ZW5zaW9ufWAgOiBuZXcgUmVnRXhwKHR5cGUpLnRlc3QoZmlsZVR5cGUpO1xyXG4gICAgICAgIGlmIChpc1ZhbGlkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge2FsbG93ZWRUeXBlcywgYWN0dWFsOiBmaWxlLnR5cGUsIGZpbGV9O1xyXG59O1xyXG5cclxuY29uc3QgY2hlY2tWYWx1ZVR5cGUgPSAodmFsdWU6IGFueSApOiB2b2lkID0+IHtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICB0aHJvdyBFcnJvcihgRm9ybUNvbnRyb2wuc2V0VmFsdWUgd2FzIHByb3ZpZGVkIHdpdGggd3JvbmcgYXJndW1lbnQgdHlwZSwgJHt2YWx1ZX0gd2FzIHByb3ZpZGVkIGluc3RlYWQgQXJyYXk8RmlsZT5gKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIEBkeW5hbWljXHJcbmV4cG9ydCBjbGFzcyBGaWxlVXBsb2FkVmFsaWRhdG9ycyB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWYWxpZGF0b3IgdGhhdCByZXF1aXJlcyBjb250cm9scyB0byBoYXZlIGEgZmlsZSBtYXhpbXVtIHNpemUgbGVuZ3RoLlxyXG4gICAgICogQ29tcGFyZSB0aGUgRmlsZSBzaXplIGluIGJ5dGVzXHJcbiAgICAgKiBAZHluYW1pY1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGZpbGVTaXplKG1heFNpemU6IG51bWJlcik6IFZhbGlkYXRvckZuIHtcclxuICAgICAgICByZXR1cm4gKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCB8IEZpbGVVcGxvYWRDb250cm9sKToge2ZpbGVTaXplOiBBcnJheTxWYWxpZGF0aW9uRXJyb3JzPn0gPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBmaWxlczogQXJyYXk8RmlsZT4gPSBjb250cm9sLnZhbHVlO1xyXG4gICAgICAgICAgICBpZiAoSXNOdWxsT3JFbXB0eShmaWxlcykpIHsgcmV0dXJuIG51bGw7IH1cclxuICAgICAgICAgICAgY2hlY2tWYWx1ZVR5cGUoZmlsZXMpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgdG9MYXJnZUZpbGVzID0gZmlsZXMubWFwKChmaWxlKSA9PiBjaGVja0ZpbGVTaXplKGZpbGUsIG1heFNpemUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoZXJyb3IpID0+IGVycm9yKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0b0xhcmdlRmlsZXMubGVuZ3RoID4gMCA/XHJcbiAgICAgICAgICAgICAgICAgICAgeydmaWxlU2l6ZSc6IHRvTGFyZ2VGaWxlc30gOiBudWxsO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wYXJlIHRoZSBGaWxlIHNpemUgaW4gYnl0ZXMgd2l0aCBtYXggYW5kIG1pbiBzaXplIGxpbWl0c1xyXG4gICAgICogQGR5bmFtaWNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzaXplUmFuZ2UoeyBtaW5TaXplLCBtYXhTaXplIH06IHsgbWluU2l6ZT86IG51bWJlcjsgbWF4U2l6ZT86IG51bWJlciB9KTogVmFsaWRhdG9yRm4ge1xyXG4gICAgICAgIHJldHVybiAoY29udHJvbDogQWJzdHJhY3RDb250cm9sIHwgRmlsZVVwbG9hZENvbnRyb2wpOiB7c2l6ZVJhbmdlOiBBcnJheTxWYWxpZGF0aW9uRXJyb3JzPn0gPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBmaWxlczogQXJyYXk8RmlsZT4gPSBjb250cm9sLnZhbHVlO1xyXG4gICAgICAgICAgICBpZiAoSXNOdWxsT3JFbXB0eShmaWxlcykpIHsgcmV0dXJuIG51bGw7IH1cclxuICAgICAgICAgICAgY2hlY2tWYWx1ZVR5cGUoZmlsZXMpO1xyXG5cclxuICAgICAgICAgICAgY29uc3Qgc2l6ZU1pc21hdGNoID0gZmlsZXMubWFwKChmaWxlKSA9PiBjaGVja0ZpbGVTaXplKGZpbGUsIG1heFNpemUsIG1pblNpemUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoZXJyb3IpID0+IGVycm9yKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzaXplTWlzbWF0Y2gubGVuZ3RoID4gMCA/XHJcbiAgICAgICAgICAgICAgICAgICAgeydzaXplUmFuZ2UnOiBzaXplTWlzbWF0Y2h9IDogbnVsbDtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogdmFsaWRhdG9yIHRoYXQgcmVxdWlyZXMgY29udHJvbCB0byBoYXZlIGxpbWl0IG9uIGZpbGVzIG51bWJlclxyXG4gICAgICogQGR5bmFtaWNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBmaWxlc0xpbWl0KG51bUZpbGVzOiBudW1iZXIpOiBWYWxpZGF0b3JGbiB7XHJcbiAgICAgICAgcmV0dXJuIChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wgfCBGaWxlVXBsb2FkQ29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBmaWxlczogQXJyYXk8RmlsZT4gPSBjb250cm9sLnZhbHVlO1xyXG4gICAgICAgICAgICBpZiAoSXNOdWxsT3JFbXB0eShmaWxlcykpIHsgcmV0dXJuIG51bGw7IH1cclxuICAgICAgICAgICAgY2hlY2tWYWx1ZVR5cGUoZmlsZXMpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZpbGVzLmxlbmd0aCA+IG51bUZpbGVzID9cclxuICAgICAgICAgICAgICAgIHsnZmlsZXNMaW1pdCc6IHsnbWF4JzogbnVtRmlsZXMsICdhY3R1YWwnOiBmaWxlcy5sZW5ndGh9fSA6IG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHZhbGlkYXRvciB0aGF0IHJlcXVpcmVzIGNvbnRyb2wgdG8gaGF2ZSBsaW1pdCBvbiBtZWRpYSB0eXBlc1xyXG4gICAgICpcclxuICAgICAqICMjIyMjIEFsbG93ZWQgbWVkaWEgdHlwZXMgYXJlXHJcbiAgICAgKlxyXG4gICAgICogLSBmaWxlX2V4dGVuc2lvbiAtIGEgZmlsZSBleHRlbnNpb24gc3RhcnRpbmcgd2l0aCB0aGUgU1RPUCBjaGFyYWN0ZXIsXHJcbiAgICAgKiBlLmc6IC5naWYsIC5qcGcsIC5wbmcsIC5kb2NcclxuICAgICAqIC0gYXVkaW8vKiAtICAgICAgICBBbGwgc291bmQgZmlsZXMgYXJlIGFjY2VwdGVkXHJcbiAgICAgKiAtIHZpZGVvLyogLSAgICAgICAgQWxsIHZpZGVvIGZpbGVzIGFyZSBhY2NlcHRlZFxyXG4gICAgICogLSBpbWFnZS8qIC0gICAgICAgIEFsbCBpbWFnZSBmaWxlcyBhcmUgYWNjZXB0ZWRcclxuICAgICAqIC0gbWVkaWFfdHlwZSAtICAgICBBIHZhbGlkIG1lZGlhIHR5cGUsIHdpdGggbm8gcGFyYW1ldGVycy4gTG9vayBhdCBbSUFOQSBNZWRpYSBUeXBlc10oaHR0cHM6Ly93d3cuaWFuYS5vcmcvYXNzaWdubWVudHMvbWVkaWEtdHlwZXMvbWVkaWEtdHlwZXMueGh0bWwpIGZvciBhIGNvbXBsZXRlIGxpc3Qgb2Ygc3RhbmRhcmQgbWVkaWEgdHlwZXNcclxuICAgICAqXHJcbiAgICAgKiAjIyMjIEV4YW1wbGVcclxuICAgICAqIGBGaWxlVXBsb2FkVmFsaWRhdG9ycy5hY2NlcHQoW2ZpbGVfZXh0ZW5zaW9uLCBhdWRpby8qLCB2aWRlby8qLCBpbWFnZS8qLCBtZWRpYV90eXBlXSlgXHJcbiAgICAgKiBAZHluYW1pY1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGFjY2VwdChhbGxvd2VkRmlsZVR5cGVzOiBBcnJheTxzdHJpbmc+KSB7XHJcbiAgICAgICAgcmV0dXJuIChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wgfCBGaWxlVXBsb2FkQ29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBmaWxlczogQXJyYXk8RmlsZT4gPSBjb250cm9sLnZhbHVlO1xyXG4gICAgICAgICAgICBpZiAoSXNOdWxsT3JFbXB0eShmaWxlcykpIHsgcmV0dXJuIG51bGw7IH1cclxuICAgICAgICAgICAgY2hlY2tWYWx1ZVR5cGUoZmlsZXMpO1xyXG5cclxuICAgICAgICAgICAgY29uc3Qgbm90QWxsb3dlZEZpbGVzID0gZmlsZXMubWFwKChmaWxlKSA9PiBjaGVja0ZpbGVUeXBlKGZpbGUsIGFsbG93ZWRGaWxlVHlwZXMpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoZXJyb3IpID0+IGVycm9yKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBub3RBbGxvd2VkRmlsZXMubGVuZ3RoID4gMCA/XHJcbiAgICAgICAgICAgICAgICB7J2ZpbGVUeXBlcyc6IG5vdEFsbG93ZWRGaWxlc30gOiBudWxsO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG59XHJcbiJdfQ==