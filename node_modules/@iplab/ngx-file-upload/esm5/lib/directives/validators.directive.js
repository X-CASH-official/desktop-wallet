/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, forwardRef, Input } from '@angular/core';
import { NG_VALIDATORS } from '@angular/forms';
import { FileUploadValidators } from './../helpers/validators.class';
import { IsNullOrEmpty } from './../helpers/helpers.class';
import { FileUploadService } from './../services/file-upload.service';
/**
 * A Directive that adds the `filesize` validator to controls marked with the
 * `filesize` attribute. The size of the file is in bytes or any other unit
 *
 * ### Example
 *
 * ```
 * <file-upload name="files" ngModel filesize="830000"></file-upload>
 * <file-upload name="files" ngModel [filesize]="830000"></file-upload>
 * <file-upload name="files" ngModel minSize="0" max="6200"></file-upload>
 * <file-upload name="files" ngModel filesize="123MB"></file-upload>
 * <file-upload name="files" ngModel [filesize]="12 mb"></file-upload>
 * <file-upload name="files" ngModel minSize="0" max="324KB"></file-upload>
 * ```
 *
 */
var FileSizeValidator = /** @class */ (function () {
    function FileSizeValidator(fileUploadService) {
        this.fileUploadService = fileUploadService;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    FileSizeValidator.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if ('filesize' in changes
            || 'maxsize' in changes
            || 'minsize' in changes) {
            this._createValidator();
            if (this.onChange) {
                this.onChange();
            }
        }
    };
    /**
     * @param {?} c
     * @return {?}
     */
    FileSizeValidator.prototype.validate = /**
     * @param {?} c
     * @return {?}
     */
    function (c) {
        return this.validator(c);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    FileSizeValidator.prototype.registerOnValidatorChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onChange = fn;
    };
    /**
     * @private
     * @return {?}
     */
    FileSizeValidator.prototype._createValidator = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var maxSize = null;
        if (!IsNullOrEmpty(this.maxsize)) {
            maxSize = this.fileUploadService.parseSize(this.maxsize);
        }
        else if (!IsNullOrEmpty(this.filesize)) {
            maxSize = this.fileUploadService.parseSize(this.filesize);
        }
        /** @type {?} */
        var minSize = this.fileUploadService.parseSize(this.minsize);
        this.validator = FileUploadValidators.sizeRange({ maxSize: maxSize, minSize: minSize });
    };
    FileSizeValidator.decorators = [
        { type: Directive, args: [{
                    selector: "[filesize][formControlName],[filesize][formControl],[filesize][ngModel],\n    [minsize][formControlName],[minsize][formControl],[minsize][ngModel],\n    [maxsize][formControlName],[maxsize][formControl],[maxsize][ngModel]",
                    providers: [{
                            provide: NG_VALIDATORS,
                            useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return FileSizeValidator; })),
                            multi: true
                        }],
                    host: {
                        '[attr.filesize]': 'filesize ? filesize : null',
                        '[attr.minsize]': 'minsize ? minsize : null',
                        '[attr.maxsize]': 'maxsize ? maxsize : null'
                    }
                },] }
    ];
    /** @nocollapse */
    FileSizeValidator.ctorParameters = function () { return [
        { type: FileUploadService }
    ]; };
    FileSizeValidator.propDecorators = {
        filesize: [{ type: Input }],
        minsize: [{ type: Input }],
        maxsize: [{ type: Input }]
    };
    return FileSizeValidator;
}());
export { FileSizeValidator };
if (false) {
    /** @type {?} */
    FileSizeValidator.prototype.filesize;
    /** @type {?} */
    FileSizeValidator.prototype.minsize;
    /** @type {?} */
    FileSizeValidator.prototype.maxsize;
    /**
     * @type {?}
     * @private
     */
    FileSizeValidator.prototype.validator;
    /**
     * @type {?}
     * @private
     */
    FileSizeValidator.prototype.onChange;
    /**
     * @type {?}
     * @private
     */
    FileSizeValidator.prototype.fileUploadService;
}
/**
 * A Directive that adds the `fileslimit` validator to controls marked with the
 * `fileslimit` attribute.
 *
 * ### Example
 *
 * ```
 * <file-upload name="files" ngModel fileslimit="2"></file-upload>
 * <file-upload name="files" ngModel [fileslimit]="2"></file-upload>
 * ```
 *
 */
var FilesLimitValidator = /** @class */ (function () {
    function FilesLimitValidator() {
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    FilesLimitValidator.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if ('fileslimit' in changes) {
            this._createValidator();
            if (this.onChange) {
                this.onChange();
            }
        }
    };
    /**
     * @param {?} c
     * @return {?}
     */
    FilesLimitValidator.prototype.validate = /**
     * @param {?} c
     * @return {?}
     */
    function (c) {
        return this.fileslimit != null ? this.validator(c) : null;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    FilesLimitValidator.prototype.registerOnValidatorChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onChange = fn;
    };
    /**
     * @private
     * @return {?}
     */
    FilesLimitValidator.prototype._createValidator = /**
     * @private
     * @return {?}
     */
    function () {
        this.validator = FileUploadValidators.filesLimit(typeof this.fileslimit === 'string' ? parseInt(this.fileslimit, 10) : this.fileslimit);
    };
    FilesLimitValidator.decorators = [
        { type: Directive, args: [{
                    selector: '[fileslimit][formControlName],[fileslimit][formControl],[fileslimit][ngModel]',
                    providers: [{
                            provide: NG_VALIDATORS,
                            useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return FilesLimitValidator; })),
                            multi: true
                        }],
                    host: { '[attr.fileslimit]': 'fileslimit ? fileslimit : null' }
                },] }
    ];
    FilesLimitValidator.propDecorators = {
        fileslimit: [{ type: Input }]
    };
    return FilesLimitValidator;
}());
export { FilesLimitValidator };
if (false) {
    /** @type {?} */
    FilesLimitValidator.prototype.fileslimit;
    /**
     * @type {?}
     * @private
     */
    FilesLimitValidator.prototype.validator;
    /**
     * @type {?}
     * @private
     */
    FilesLimitValidator.prototype.onChange;
}
/**
 * A Directive that adds the `accept` validator to controls marked with the
 * `accept` attribute.
 *
 * ### Example
 *
 * ```
 * <file-upload name="files" ngModel accept="file_extension|audio/*|video/*|image/*|media_type"></file-upload>
 * <file-upload name="files" ngModel [accept]="file_extension|audio/*|video/*|image/*|media_type"></file-upload>
 * ```
 *
 * To specify more than one value, separate the values with a comma (e.g. <file-upload accept="audio/*,video/*,image/*"></file-upload>.
 *
 */
var FilesAcceptValidator = /** @class */ (function () {
    function FilesAcceptValidator() {
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    FilesAcceptValidator.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if ('accept' in changes) {
            this._createValidator();
            if (this.onChange) {
                this.onChange();
            }
        }
    };
    /**
     * @param {?} c
     * @return {?}
     */
    FilesAcceptValidator.prototype.validate = /**
     * @param {?} c
     * @return {?}
     */
    function (c) {
        return this.accept != null ? this.validator(c) : null;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    FilesAcceptValidator.prototype.registerOnValidatorChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onChange = fn;
    };
    /**
     * @private
     * @return {?}
     */
    FilesAcceptValidator.prototype._createValidator = /**
     * @private
     * @return {?}
     */
    function () {
        this.validator = FileUploadValidators.accept(this.accept.split(','));
    };
    FilesAcceptValidator.decorators = [
        { type: Directive, args: [{
                    selector: '[accept][formControlName],[accept][formControl],[accept][ngModel]',
                    providers: [{
                            provide: NG_VALIDATORS,
                            useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return FilesAcceptValidator; })),
                            multi: true
                        }],
                    host: { '[attr.accept]': 'accept ? accept : null' }
                },] }
    ];
    FilesAcceptValidator.propDecorators = {
        accept: [{ type: Input }]
    };
    return FilesAcceptValidator;
}());
export { FilesAcceptValidator };
if (false) {
    /** @type {?} */
    FilesAcceptValidator.prototype.accept;
    /**
     * @type {?}
     * @private
     */
    FilesAcceptValidator.prototype.validator;
    /**
     * @type {?}
     * @private
     */
    FilesAcceptValidator.prototype.onChange;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdG9ycy5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AaXBsYWIvbmd4LWZpbGUtdXBsb2FkLyIsInNvdXJjZXMiOlsibGliL2RpcmVjdGl2ZXMvdmFsaWRhdG9ycy5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBK0QsTUFBTSxlQUFlLENBQUM7QUFDMUgsT0FBTyxFQUFFLGFBQWEsRUFBOEIsTUFBTSxnQkFBZ0IsQ0FBQztBQUMzRSxPQUFPLEVBQWlDLG9CQUFvQixFQUFFLE1BQU0sK0JBQStCLENBQUM7QUFDcEcsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQzNELE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLG1DQUFtQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQW1CdEU7SUE0QkksMkJBQTZCLGlCQUFvQztRQUFwQyxzQkFBaUIsR0FBakIsaUJBQWlCLENBQW1CO0lBQUUsQ0FBQzs7Ozs7SUFJN0QsdUNBQVc7Ozs7SUFBbEIsVUFBbUIsT0FBc0I7UUFDckMsSUFBSSxVQUFVLElBQUksT0FBTztlQUNsQixTQUFTLElBQUksT0FBTztlQUNwQixTQUFTLElBQUksT0FBTyxFQUFFO1lBQzNCLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1lBQ3hCLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtnQkFDZixJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7YUFDbkI7U0FDRjtJQUNMLENBQUM7Ozs7O0lBRU0sb0NBQVE7Ozs7SUFBZixVQUFnQixDQUFrQjtRQUM5QixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDN0IsQ0FBQzs7Ozs7SUFFTSxxREFBeUI7Ozs7SUFBaEMsVUFBaUMsRUFBYztRQUMzQyxJQUFJLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQztJQUN2QixDQUFDOzs7OztJ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SyxFQUFFLElBQUk7eUJBQ2QsQ0FBQztvQkFDRixJQUFJLEVBQUUsRUFBQyxlQUFlLEVBQUUsd0JBQXdCLEVBQUM7aUJBQ3BEOzs7eUJBR0ksS0FBSzs7SUEyQlYsMkJBQUM7Q0FBQSxBQXRDRCxJQXNDQztTQTdCWSxvQkFBb0I7OztJQUU3QixzQ0FDc0I7Ozs7O0lBRXRCLHlDQUErQjs7Ozs7SUFFL0Isd0NBQTZCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGlyZWN0aXZlLCBmb3J3YXJkUmVmLCBJbnB1dCwgT25DaGFuZ2VzLCBTaW1wbGVDaGFuZ2VzLCBIb3N0LCBTZWxmLCBPcHRpb25hbCwgSG9zdEJpbmRpbmcgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgTkdfVkFMSURBVE9SUywgVmFsaWRhdG9yLCBBYnN0cmFjdENvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XHJcbmltcG9ydCB7IFZhbGlkYXRpb25FcnJvcnMsIFZhbGlkYXRvckZuLCBGaWxlVXBsb2FkVmFsaWRhdG9ycyB9IGZyb20gJy4vLi4vaGVscGVycy92YWxpZGF0b3JzLmNsYXNzJztcclxuaW1wb3J0IHsgSXNOdWxsT3JFbXB0eSB9IGZyb20gJy4vLi4vaGVscGVycy9oZWxwZXJzLmNsYXNzJztcclxuaW1wb3J0IHsgRmlsZVVwbG9hZFNlcnZpY2UgfSBmcm9tICcuLy4uL3NlcnZpY2VzL2ZpbGUtdXBsb2FkLnNlcnZpY2UnO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBBIERpcmVjdGl2ZSB0aGF0IGFkZHMgdGhlIGBmaWxlc2l6ZWAgdmFsaWRhdG9yIHRvIGNvbnRyb2xzIG1hcmtlZCB3aXRoIHRoZVxyXG4gKiBgZmlsZXNpemVgIGF0dHJpYnV0ZS4gVGhlIHNpemUgb2YgdGhlIGZpbGUgaXMgaW4gYnl0ZXMgb3IgYW55IG90aGVyIHVuaXRcclxuICpcclxuICogIyMjIEV4YW1wbGVcclxuICpcclxuICogYGBgXHJcbiAqIDxmaWxlLXVwbG9hZCBuYW1lPVwiZmlsZXNcIiBuZ01vZGVsIGZpbGVzaXplPVwiODMwMDAwXCI+PC9maWxlLXVwbG9hZD5cclxuICogPGZpbGUtdXBsb2FkIG5hbWU9XCJmaWxlc1wiIG5nTW9kZWwgW2ZpbGVzaXplXT1cIjgzMDAwMFwiPjwvZmlsZS11cGxvYWQ+XHJcbiAqIDxmaWxlLXVwbG9hZCBuYW1lPVwiZmlsZXNcIiBuZ01vZGVsIG1pblNpemU9XCIwXCIgbWF4PVwiNjIwMFwiPjwvZmlsZS11cGxvYWQ+XHJcbiAqIDxmaWxlLXVwbG9hZCBuYW1lPVwiZmlsZXNcIiBuZ01vZGVsIGZpbGVzaXplPVwiMTIzTUJcIj48L2ZpbGUtdXBsb2FkPlxyXG4gKiA8ZmlsZS11cGxvYWQgbmFtZT1cImZpbGVzXCIgbmdNb2RlbCBbZmlsZXNpemVdPVwiMTIgbWJcIj48L2ZpbGUtdXBsb2FkPlxyXG4gKiA8ZmlsZS11cGxvYWQgbmFtZT1cImZpbGVzXCIgbmdNb2RlbCBtaW5TaXplPVwiMFwiIG1heD1cIjMyNEtCXCI+PC9maWxlLXVwbG9hZD5cclxuICogYGBgXHJcbiAqXHJcbiAqL1xyXG5ARGlyZWN0aXZlKHtcclxuICAgIHNlbGVjdG9yOiBgW2ZpbGVzaXplXVtmb3JtQ29udHJvbE5hbWVdLFtmaWxlc2l6ZV1bZm9ybUNvbnRyb2xdLFtmaWxlc2l6ZV1bbmdNb2RlbF0sXHJcbiAgICBbbWluc2l6ZV1bZm9ybUNvbnRyb2xOYW1lXSxbbWluc2l6ZV1bZm9ybUNvbnRyb2xdLFttaW5zaXplXVtuZ01vZGVsXSxcclxuICAgIFttYXhzaXplXVtmb3JtQ29udHJvbE5hbWVdLFttYXhzaXplXVtmb3JtQ29udHJvbF0sW21heHNpemVdW25nTW9kZWxdYCxcclxuICAgIHByb3ZpZGVyczogW3tcclxuICAgICAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxyXG4gICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEZpbGVTaXplVmFsaWRhdG9yKSxcclxuICAgICAgICBtdWx0aTogdHJ1ZVxyXG4gICAgfV0sXHJcbiAgICBob3N0OiB7XHJcbiAgICAgICAgJ1thdHRyLmZpbGVzaXplXSc6ICdmaWxlc2l6ZSA/IGZpbGVzaXplIDogbnVsbCcsXHJcbiAgICAgICAgJ1thdHRyLm1pbnNpemVdJzogJ21pbnNpemUgPyBtaW5zaXplIDogbnVsbCcsXHJcbiAgICAgICAgJ1thdHRyLm1heHNpemVdJzogJ21heHNpemUgPyBtYXhzaXplIDogbnVsbCdcclxuICAgIH1cclxufSlcclxuZXhwb3J0IGNsYXNzIEZpbGVTaXplVmFsaWRhdG9yIGltcGxlbWVudHMgVmFsaWRhdG9yLCBPbkNoYW5nZXMge1xyXG5cclxuICAgIEBJbnB1dCgpXHJcbiAgICBwdWJsaWMgZmlsZXNpemU6IHN0cmluZ3xudW1iZXI7XHJcblxyXG4gICAgQElucHV0KClcclxuICAgIHB1YmxpYyBtaW5zaXplOiBzdHJpbmd8bnVtYmVyO1xyXG5cclxuICAgIEBJbnB1dCgpXHJcbiAgICBwdWJsaWMgbWF4c2l6ZTogc3RyaW5nfG51bWJlcjtcclxuXHJcbiAgICBwcml2YXRlIHZhbGlkYXRvcjogVmFsaWRhdG9yRm47XHJcblxyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBmaWxlVXBsb2FkU2VydmljZTogRmlsZVVwbG9hZFNlcnZpY2Upe31cclxuXHJcbiAgICBwcml2YXRlIG9uQ2hhbmdlOiAoKSA9PiB2b2lkO1xyXG5cclxuICAgIHB1YmxpYyBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCdmaWxlc2l6ZScgaW4gY2hhbmdlcyBcclxuICAgICAgICAgICAgfHwgJ21heHNpemUnIGluIGNoYW5nZXMgXHJcbiAgICAgICAgICAgIHx8ICdtaW5zaXplJyBpbiBjaGFuZ2VzKSB7XHJcbiAgICAgICAgICB0aGlzLl9jcmVhdGVWYWxpZGF0b3IoKTtcclxuICAgICAgICAgIGlmICh0aGlzLm9uQ2hhbmdlKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdmFsaWRhdGUoYzogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9yc3xudWxsIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0b3IoYyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZm46ICgpID0+IHZvaWQpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZm47IFxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2NyZWF0ZVZhbGlkYXRvcigpOiB2b2lkIHtcclxuICAgICAgICBsZXQgbWF4U2l6ZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKCFJc051bGxPckVtcHR5KHRoaXMubWF4c2l6ZSkpIHtcclxuICAgICAgICAgICAgbWF4U2l6ZSA9IHRoaXMuZmlsZVVwbG9hZFNlcnZpY2UucGFyc2VTaXplKHRoaXMubWF4c2l6ZSk7XHJcbiAgICAgICAgfSBlbHNlIGlmKCFJc051bGxPckVtcHR5KHRoaXMuZmlsZXNpemUpKSB7XHJcbiAgICAgICAgICAgIG1heFNpemUgPSB0aGlzLmZpbGVVcGxvYWRTZXJ2aWNlLnBhcnNlU2l6ZSh0aGlzLmZpbGVzaXplKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IG1pblNpemUgPSB0aGlzLmZpbGVVcGxvYWRTZXJ2aWNlLnBhcnNlU2l6ZSh0aGlzLm1pbnNpemUpO1xyXG4gICAgICAgIHRoaXMudmFsaWRhdG9yID0gRmlsZVVwbG9hZFZhbGlkYXRvcnMuc2l6ZVJhbmdlKHsgbWF4U2l6ZSwgbWluU2l6ZSB9KTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBBIERpcmVjdGl2ZSB0aGF0IGFkZHMgdGhlIGBmaWxlc2xpbWl0YCB2YWxpZGF0b3IgdG8gY29udHJvbHMgbWFya2VkIHdpdGggdGhlXHJcbiAqIGBmaWxlc2xpbWl0YCBhdHRyaWJ1dGUuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiA8ZmlsZS11cGxvYWQgbmFtZT1cImZpbGVzXCIgbmdNb2RlbCBmaWxlc2xpbWl0PVwiMlwiPjwvZmlsZS11cGxvYWQ+XHJcbiAqIDxmaWxlLXVwbG9hZCBuYW1lPVwiZmlsZXNcIiBuZ01vZGVsIFtmaWxlc2xpbWl0XT1cIjJcIj48L2ZpbGUtdXBsb2FkPlxyXG4gKiBgYGBcclxuICpcclxuICovXHJcbkBEaXJlY3RpdmUoe1xyXG4gICAgc2VsZWN0b3I6ICdbZmlsZXNsaW1pdF1bZm9ybUNvbnRyb2xOYW1lXSxbZmlsZXNsaW1pdF1bZm9ybUNvbnRyb2xdLFtmaWxlc2xpbWl0XVtuZ01vZGVsXScsXHJcbiAgICBwcm92aWRlcnM6IFt7XHJcbiAgICAgICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcclxuICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBGaWxlc0xpbWl0VmFsaWRhdG9yKSxcclxuICAgICAgICBtdWx0aTogdHJ1ZVxyXG4gICAgfV0sXHJcbiAgICBob3N0OiB7J1thdHRyLmZpbGVzbGltaXRdJzogJ2ZpbGVzbGltaXQgPyBmaWxlc2xpbWl0IDogbnVsbCd9XHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBGaWxlc0xpbWl0VmFsaWRhdG9yIGltcGxlbWVudHMgVmFsaWRhdG9yLCBPbkNoYW5nZXMge1xyXG5cclxuICAgIEBJbnB1dCgpXHJcbiAgICBwdWJsaWMgZmlsZXNsaW1pdDogc3RyaW5nfG51bWJlcjtcclxuXHJcbiAgICBwcml2YXRlIHZhbGlkYXRvcjogVmFsaWRhdG9yRm47XHJcblxyXG4gICAgcHJpdmF0ZSBvbkNoYW5nZTogKCkgPT4gdm9pZDtcclxuXHJcbiAgICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xyXG4gICAgICAgIGlmICgnZmlsZXNsaW1pdCcgaW4gY2hhbmdlcykge1xyXG4gICAgICAgICAgdGhpcy5fY3JlYXRlVmFsaWRhdG9yKCk7XHJcbiAgICAgICAgICBpZiAodGhpcy5vbkNoYW5nZSkge1xyXG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB2YWxpZGF0ZShjOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzfG51bGwge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZpbGVzbGltaXQgIT0gbnVsbCA/IHRoaXMudmFsaWRhdG9yKGMpIDogbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShmbjogKCkgPT4gdm9pZCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSBmbjsgXHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfY3JlYXRlVmFsaWRhdG9yKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMudmFsaWRhdG9yID0gRmlsZVVwbG9hZFZhbGlkYXRvcnMuZmlsZXNMaW1pdCh0eXBlb2YgdGhpcy5maWxlc2xpbWl0ID09PSAnc3RyaW5nJyA/IHBhcnNlSW50KHRoaXMuZmlsZXNsaW1pdCwgMTApIDogdGhpcy5maWxlc2xpbWl0KTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEEgRGlyZWN0aXZlIHRoYXQgYWRkcyB0aGUgYGFjY2VwdGAgdmFsaWRhdG9yIHRvIGNvbnRyb2xzIG1hcmtlZCB3aXRoIHRoZVxyXG4gKiBgYWNjZXB0YCBhdHRyaWJ1dGUuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiA8ZmlsZS11cGxvYWQgbmFtZT1cImZpbGVzXCIgbmdNb2RlbCBhY2NlcHQ9XCJmaWxlX2V4dGVuc2lvbnxhdWRpby8qfHZpZGVvLyp8aW1hZ2UvKnxtZWRpYV90eXBlXCI+PC9maWxlLXVwbG9hZD5cclxuICogPGZpbGUtdXBsb2FkIG5hbWU9XCJmaWxlc1wiIG5nTW9kZWwgW2FjY2VwdF09XCJmaWxlX2V4dGVuc2lvbnxhdWRpby8qfHZpZGVvLyp8aW1hZ2UvKnxtZWRpYV90eXBlXCI+PC9maWxlLXVwbG9hZD5cclxuICogYGBgXHJcbiAqIFxyXG4gKiBUbyBzcGVjaWZ5IG1vcmUgdGhhbiBvbmUgdmFsdWUsIHNlcGFyYXRlIHRoZSB2YWx1ZXMgd2l0aCBhIGNvbW1hIChlLmcuIDxmaWxlLXVwbG9hZCBhY2NlcHQ9XCJhdWRpby8qLHZpZGVvLyosaW1hZ2UvKlwiPjwvZmlsZS11cGxvYWQ+LlxyXG4gKlxyXG4gKi9cclxuQERpcmVjdGl2ZSh7XHJcbiAgICBzZWxlY3RvcjogJ1thY2NlcHRdW2Zvcm1Db250cm9sTmFtZV0sW2FjY2VwdF1bZm9ybUNvbnRyb2xdLFthY2NlcHRdW25nTW9kZWxdJyxcclxuICAgIHByb3ZpZGVyczogW3tcclxuICAgICAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxyXG4gICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEZpbGVzQWNjZXB0VmFsaWRhdG9yKSxcclxuICAgICAgICBtdWx0aTogdHJ1ZVxyXG4gICAgfV0sXHJcbiAgICBob3N0OiB7J1thdHRyLmFjY2VwdF0nOiAnYWNjZXB0ID8gYWNjZXB0IDogbnVsbCd9XHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBGaWxlc0FjY2VwdFZhbGlkYXRvciBpbXBsZW1lbnRzIFZhbGlkYXRvciwgT25DaGFuZ2VzIHtcclxuXHJcbiAgICBASW5wdXQoKVxyXG4gICAgcHVibGljIGFjY2VwdDogc3RyaW5nO1xyXG5cclxuICAgIHByaXZhdGUgdmFsaWRhdG9yOiBWYWxpZGF0b3JGbjtcclxuXHJcbiAgICBwcml2YXRlIG9uQ2hhbmdlOiAoKSA9PiB2b2lkO1xyXG5cclxuICAgIHB1YmxpYyBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCdhY2NlcHQnIGluIGNoYW5nZXMpIHtcclxuICAgICAgICAgIHRoaXMuX2NyZWF0ZVZhbGlkYXRvcigpO1xyXG4gICAgICAgICAgaWYgKHRoaXMub25DaGFuZ2UpIHtcclxuICAgICAgICAgICAgICB0aGlzLm9uQ2hhbmdlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB2YWxpZGF0ZShjOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzfG51bGwge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFjY2VwdCAhPSBudWxsID8gdGhpcy52YWxpZGF0b3IoYykgOiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZuO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2NyZWF0ZVZhbGlkYXRvcigpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnZhbGlkYXRvciA9IEZpbGVVcGxvYWRWYWxpZGF0b3JzLmFjY2VwdCh0aGlzLmFjY2VwdC5zcGxpdCgnLCcpKTtcclxuICAgIH1cclxufVxyXG4iXX0=