/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, forwardRef, Input } from '@angular/core';
import { NG_VALIDATORS } from '@angular/forms';
import { FileUploadValidators } from './../helpers/validators.class';
import { IsNullOrEmpty } from './../helpers/helpers.class';
import { FileUploadService } from './../services/file-upload.service';
/**
 * A Directive that adds the `filesize` validator to controls marked with the
 * `filesize` attribute. The size of the file is in bytes or any other unit
 *
 * ### Example
 *
 * ```
 * <file-upload name="files" ngModel filesize="830000"></file-upload>
 * <file-upload name="files" ngModel [filesize]="830000"></file-upload>
 * <file-upload name="files" ngModel minSize="0" max="6200"></file-upload>
 * <file-upload name="files" ngModel filesize="123MB"></file-upload>
 * <file-upload name="files" ngModel [filesize]="12 mb"></file-upload>
 * <file-upload name="files" ngModel minSize="0" max="324KB"></file-upload>
 * ```
 *
 */
export class FileSizeValidator {
    /**
     * @param {?} fileUploadService
     */
    constructor(fileUploadService) {
        this.fileUploadService = fileUploadService;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if ('filesize' in changes
            || 'maxsize' in changes
            || 'minsize' in changes) {
            this._createValidator();
            if (this.onChange) {
                this.onChange();
            }
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
    /**
     * @private
     * @return {?}
     */
    _createValidator() {
        /** @type {?} */
        let maxSize = null;
        if (!IsNullOrEmpty(this.maxsize)) {
            maxSize = this.fileUploadService.parseSize(this.maxsize);
        }
        else if (!IsNullOrEmpty(this.filesize)) {
            maxSize = this.fileUploadService.parseSize(this.filesize);
        }
        /** @type {?} */
        const minSize = this.fileUploadService.parseSize(this.minsize);
        this.validator = FileUploadValidators.sizeRange({ maxSize, minSize });
    }
}
FileSizeValidator.decorators = [
    { type: Directive, args: [{
                selector: `[filesize][formControlName],[filesize][formControl],[filesize][ngModel],
    [minsize][formControlName],[minsize][formControl],[minsize][ngModel],
    [maxsize][formControlName],[maxsize][formControl],[maxsize][ngModel]`,
                providers: [{
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => FileSizeValidator)),
                        multi: true
                    }],
                host: {
                    '[attr.filesize]': 'filesize ? filesize : null',
                    '[attr.minsize]': 'minsize ? minsize : null',
                    '[attr.maxsize]': 'maxsize ? maxsize : null'
                }
            },] }
];
/** @nocollapse */
FileSizeValidator.ctorParameters = () => [
    { type: FileUploadService }
];
FileSizeValidator.propDecorators = {
    filesize: [{ type: Input }],
    minsize: [{ type: Input }],
    maxsize: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    FileSizeValidator.prototype.filesize;
    /** @type {?} */
    FileSizeValidator.prototype.minsize;
    /** @type {?} */
    FileSizeValidator.prototype.maxsize;
    /**
     * @type {?}
     * @private
     */
    FileSizeValidator.prototype.validator;
    /**
     * @type {?}
     * @private
     */
    FileSizeValidator.prototype.onChange;
    /**
     * @type {?}
     * @private
     */
    FileSizeValidator.prototype.fileUploadService;
}
/**
 * A Directive that adds the `fileslimit` validator to controls marked with the
 * `fileslimit` attribute.
 *
 * ### Example
 *
 * ```
 * <file-upload name="files" ngModel fileslimit="2"></file-upload>
 * <file-upload name="files" ngModel [fileslimit]="2"></file-upload>
 * ```
 *
 */
export class FilesLimitValidator {
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if ('fileslimit' in changes) {
            this._createValidator();
            if (this.onChange) {
                this.onChange();
            }
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.fileslimit != null ? this.validator(c) : null;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
    /**
     * @private
     * @return {?}
     */
    _createValidator() {
        this.validator = FileUploadValidators.filesLimit(typeof this.fileslimit === 'string' ? parseInt(this.fileslimit, 10) : this.fileslimit);
    }
}
FilesLimitValidator.decorators = [
    { type: Directive, args: [{
                selector: '[fileslimit][formControlName],[fileslimit][formControl],[fileslimit][ngModel]',
                providers: [{
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => FilesLimitValidator)),
                        multi: true
                    }],
                host: { '[attr.fileslimit]': 'fileslimit ? fileslimit : null' }
            },] }
];
FilesLimitValidator.propDecorators = {
    fileslimit: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    FilesLimitValidator.prototype.fileslimit;
    /**
     * @type {?}
     * @private
     */
    FilesLimitValidator.prototype.validator;
    /**
     * @type {?}
     * @private
     */
    FilesLimitValidator.prototype.onChange;
}
/**
 * A Directive that adds the `accept` validator to controls marked with the
 * `accept` attribute.
 *
 * ### Example
 *
 * ```
 * <file-upload name="files" ngModel accept="file_extension|audio/*|video/*|image/*|media_type"></file-upload>
 * <file-upload name="files" ngModel [accept]="file_extension|audio/*|video/*|image/*|media_type"></file-upload>
 * ```
 *
 * To specify more than one value, separate the values with a comma (e.g. <file-upload accept="audio/*,video/*,image/*"></file-upload>.
 *
 */
export class FilesAcceptValidator {
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if ('accept' in changes) {
            this._createValidator();
            if (this.onChange) {
                this.onChange();
            }
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.accept != null ? this.validator(c) : null;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
    /**
     * @private
     * @return {?}
     */
    _createValidator() {
        this.validator = FileUploadValidators.accept(this.accept.split(','));
    }
}
FilesAcceptValidator.decorators = [
    { type: Directive, args: [{
                selector: '[accept][formControlName],[accept][formControl],[accept][ngModel]',
                providers: [{
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => FilesAcceptValidator)),
                        multi: true
                    }],
                host: { '[attr.accept]': 'accept ? accept : null' }
            },] }
];
FilesAcceptValidator.propDecorators = {
    accept: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    FilesAcceptValidator.prototype.accept;
    /**
     * @type {?}
     * @private
     */
    FilesAcceptValidator.prototype.validator;
    /**
     * @type {?}
     * @private
     */
    FilesAcceptValidator.prototype.onChange;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdG9ycy5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AaXBsYWIvbmd4LWZpbGUtdXBsb2FkLyIsInNvdXJjZXMiOlsibGliL2RpcmVjdGl2ZXMvdmFsaWRhdG9ycy5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBK0QsTUFBTSxlQUFlLENBQUM7QUFDMUgsT0FBTyxFQUFFLGFBQWEsRUFBOEIsTUFBTSxnQkFBZ0IsQ0FBQztBQUMzRSxPQUFPLEVBQWlDLG9CQUFvQixFQUFFLE1BQU0sK0JBQStCLENBQUM7QUFDcEcsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQzNELE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLG1DQUFtQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQWtDdEUsTUFBTSxPQUFPLGlCQUFpQjs7OztJQWExQixZQUE2QixpQkFBb0M7UUFBcEMsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFtQjtJQUFFLENBQUM7Ozs7O0lBSTdELFdBQVcsQ0FBQyxPQUFzQjtRQUNyQyxJQUFJLFVBQVUsSUFBSSxPQUFPO2VBQ2xCLFNBQVMsSUFBSSxPQUFPO2VBQ3BCLFNBQVMsSUFBSSxPQUFPLEVBQUU7WUFDM0IsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7WUFDeEIsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO2dCQUNmLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQzthQUNuQjtTQUNGO0lBQ0wsQ0FBQzs7Ozs7SUFFTSxRQUFRLENBQUMsQ0FBa0I7UUFDOUIsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzdCLENBQUM7Ozs7O0lBRU0seUJBQXlCLENBQUMsRUFBYztRQUMzQyxJQUFJLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQztJQUN2QixDQUFDOzs7OztJQUVPLGdCQUFnQjs7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Q2pDLE1BQU0sT0FBTyxvQkFBb0I7Ozs7O0lBU3RCLFdBQVcsQ0FBQyxPQUFzQjtRQUNyQyxJQUFJLFFBQVEsSUFBSSxPQUFPLEVBQUU7WUFDdkIsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7WUFDeEIsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO2dCQUNmLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQzthQUNuQjtTQUNGO0lBQ0wsQ0FBQzs7Ozs7SUFFTSxRQUFRLENBQUMsQ0FBa0I7UUFDOUIsT0FBTyxJQUFJLENBQUMsTUFBTSxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO0lBQzFELENBQUM7Ozs7O0lBRU0seUJBQXlCLENBQUMsRUFBYztRQUMzQyxJQUFJLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQztJQUN2QixDQUFDOzs7OztJQUVPLGdCQUFnQjtRQUNwQixJQUFJLENBQUMsU0FBUyxHQUFHLG9CQUFvQixDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ3pFLENBQUM7OztZQXJDSixTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLG1FQUFtRTtnQkFDN0UsU0FBUyxFQUFFLENBQUM7d0JBQ1IsT0FBTyxFQUFFLGFBQWE7d0JBQ3RCLFdBQVcsRUFBRSxVQUFVOzs7d0JBQUMsR0FBRyxFQUFFLENBQUMsb0JBQW9CLEVBQUM7d0JBQ25ELEtBQUssRUFBRSxJQUFJO3FCQUNkLENBQUM7Z0JBQ0YsSUFBSSxFQUFFLEVBQUMsZUFBZSxFQUFFLHdCQUF3QixFQUFDO2FBQ3BEOzs7cUJBR0ksS0FBSzs7OztJQUFOLHNDQUNzQjs7Ozs7SUFFdEIseUNBQStCOzs7OztJQUUvQix3Q0FBNkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3RpdmUsIGZvcndhcmRSZWYsIElucHV0LCBPbkNoYW5nZXMsIFNpbXBsZUNoYW5nZXMsIEhvc3QsIFNlbGYsIE9wdGlvbmFsLCBIb3N0QmluZGluZyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBOR19WQUxJREFUT1JTLCBWYWxpZGF0b3IsIEFic3RyYWN0Q29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcclxuaW1wb3J0IHsgVmFsaWRhdGlvbkVycm9ycywgVmFsaWRhdG9yRm4sIEZpbGVVcGxvYWRWYWxpZGF0b3JzIH0gZnJvbSAnLi8uLi9oZWxwZXJzL3ZhbGlkYXRvcnMuY2xhc3MnO1xyXG5pbXBvcnQgeyBJc051bGxPckVtcHR5IH0gZnJvbSAnLi8uLi9oZWxwZXJzL2hlbHBlcnMuY2xhc3MnO1xyXG5pbXBvcnQgeyBGaWxlVXBsb2FkU2VydmljZSB9IGZyb20gJy4vLi4vc2VydmljZXMvZmlsZS11cGxvYWQuc2VydmljZSc7XHJcblxyXG5cclxuLyoqXHJcbiAqIEEgRGlyZWN0aXZlIHRoYXQgYWRkcyB0aGUgYGZpbGVzaXplYCB2YWxpZGF0b3IgdG8gY29udHJvbHMgbWFya2VkIHdpdGggdGhlXHJcbiAqIGBmaWxlc2l6ZWAgYXR0cmlidXRlLiBUaGUgc2l6ZSBvZiB0aGUgZmlsZSBpcyBpbiBieXRlcyBvciBhbnkgb3RoZXIgdW5pdFxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBcclxuICogPGZpbGUtdXBsb2FkIG5hbWU9XCJmaWxlc1wiIG5nTW9kZWwgZmlsZXNpemU9XCI4MzAwMDBcIj48L2ZpbGUtdXBsb2FkPlxyXG4gKiA8ZmlsZS11cGxvYWQgbmFtZT1cImZpbGVzXCIgbmdNb2RlbCBbZmlsZXNpemVdPVwiODMwMDAwXCI+PC9maWxlLXVwbG9hZD5cclxuICogPGZpbGUtdXBsb2FkIG5hbWU9XCJmaWxlc1wiIG5nTW9kZWwgbWluU2l6ZT1cIjBcIiBtYXg9XCI2MjAwXCI+PC9maWxlLXVwbG9hZD5cclxuICogPGZpbGUtdXBsb2FkIG5hbWU9XCJmaWxlc1wiIG5nTW9kZWwgZmlsZXNpemU9XCIxMjNNQlwiPjwvZmlsZS11cGxvYWQ+XHJcbiAqIDxmaWxlLXVwbG9hZCBuYW1lPVwiZmlsZXNcIiBuZ01vZGVsIFtmaWxlc2l6ZV09XCIxMiBtYlwiPjwvZmlsZS11cGxvYWQ+XHJcbiAqIDxmaWxlLXVwbG9hZCBuYW1lPVwiZmlsZXNcIiBuZ01vZGVsIG1pblNpemU9XCIwXCIgbWF4PVwiMzI0S0JcIj48L2ZpbGUtdXBsb2FkPlxyXG4gKiBgYGBcclxuICpcclxuICovXHJcbkBEaXJlY3RpdmUoe1xyXG4gICAgc2VsZWN0b3I6IGBbZmlsZXNpemVdW2Zvcm1Db250cm9sTmFtZV0sW2ZpbGVzaXplXVtmb3JtQ29udHJvbF0sW2ZpbGVzaXplXVtuZ01vZGVsXSxcclxuICAgIFttaW5zaXplXVtmb3JtQ29udHJvbE5hbWVdLFttaW5zaXplXVtmb3JtQ29udHJvbF0sW21pbnNpemVdW25nTW9kZWxdLFxyXG4gICAgW21heHNpemVdW2Zvcm1Db250cm9sTmFtZV0sW21heHNpemVdW2Zvcm1Db250cm9sXSxbbWF4c2l6ZV1bbmdNb2RlbF1gLFxyXG4gICAgcHJvdmlkZXJzOiBbe1xyXG4gICAgICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXHJcbiAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRmlsZVNpemVWYWxpZGF0b3IpLFxyXG4gICAgICAgIG11bHRpOiB0cnVlXHJcbiAgICB9XSxcclxuICAgIGhvc3Q6IHtcclxuICAgICAgICAnW2F0dHIuZmlsZXNpemVdJzogJ2ZpbGVzaXplID8gZmlsZXNpemUgOiBudWxsJyxcclxuICAgICAgICAnW2F0dHIubWluc2l6ZV0nOiAnbWluc2l6ZSA/IG1pbnNpemUgOiBudWxsJyxcclxuICAgICAgICAnW2F0dHIubWF4c2l6ZV0nOiAnbWF4c2l6ZSA/IG1heHNpemUgOiBudWxsJ1xyXG4gICAgfVxyXG59KVxyXG5leHBvcnQgY2xhc3MgRmlsZVNpemVWYWxpZGF0b3IgaW1wbGVtZW50cyBWYWxpZGF0b3IsIE9uQ2hhbmdlcyB7XHJcblxyXG4gICAgQElucHV0KClcclxuICAgIHB1YmxpYyBmaWxlc2l6ZTogc3RyaW5nfG51bWJlcjtcclxuXHJcbiAgICBASW5wdXQoKVxyXG4gICAgcHVibGljIG1pbnNpemU6IHN0cmluZ3xudW1iZXI7XHJcblxyXG4gICAgQElucHV0KClcclxuICAgIHB1YmxpYyBtYXhzaXplOiBzdHJpbmd8bnVtYmVyO1xyXG5cclxuICAgIHByaXZhdGUgdmFsaWRhdG9yOiBWYWxpZGF0b3JGbjtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGZpbGVVcGxvYWRTZXJ2aWNlOiBGaWxlVXBsb2FkU2VydmljZSl7fVxyXG5cclxuICAgIHByaXZhdGUgb25DaGFuZ2U6ICgpID0+IHZvaWQ7XHJcblxyXG4gICAgcHVibGljIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcclxuICAgICAgICBpZiAoJ2ZpbGVzaXplJyBpbiBjaGFuZ2VzIFxyXG4gICAgICAgICAgICB8fCAnbWF4c2l6ZScgaW4gY2hhbmdlcyBcclxuICAgICAgICAgICAgfHwgJ21pbnNpemUnIGluIGNoYW5nZXMpIHtcclxuICAgICAgICAgIHRoaXMuX2NyZWF0ZVZhbGlkYXRvcigpO1xyXG4gICAgICAgICAgaWYgKHRoaXMub25DaGFuZ2UpIHtcclxuICAgICAgICAgICAgICB0aGlzLm9uQ2hhbmdlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB2YWxpZGF0ZShjOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzfG51bGwge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRvcihjKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShmbjogKCkgPT4gdm9pZCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSBmbjsgXHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfY3JlYXRlVmFsaWRhdG9yKCk6IHZvaWQge1xyXG4gICAgICAgIGxldCBtYXhTaXplID0gbnVsbDtcclxuICAgICAgICBpZiAoIUlzTnVsbE9yRW1wdHkodGhpcy5tYXhzaXplKSkge1xyXG4gICAgICAgICAgICBtYXhTaXplID0gdGhpcy5maWxlVXBsb2FkU2VydmljZS5wYXJzZVNpemUodGhpcy5tYXhzaXplKTtcclxuICAgICAgICB9IGVsc2UgaWYoIUlzTnVsbE9yRW1wdHkodGhpcy5maWxlc2l6ZSkpIHtcclxuICAgICAgICAgICAgbWF4U2l6ZSA9IHRoaXMuZmlsZVVwbG9hZFNlcnZpY2UucGFyc2VTaXplKHRoaXMuZmlsZXNpemUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgbWluU2l6ZSA9IHRoaXMuZmlsZVVwbG9hZFNlcnZpY2UucGFyc2VTaXplKHRoaXMubWluc2l6ZSk7XHJcbiAgICAgICAgdGhpcy52YWxpZGF0b3IgPSBGaWxlVXBsb2FkVmFsaWRhdG9ycy5zaXplUmFuZ2UoeyBtYXhTaXplLCBtaW5TaXplIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIEEgRGlyZWN0aXZlIHRoYXQgYWRkcyB0aGUgYGZpbGVzbGltaXRgIHZhbGlkYXRvciB0byBjb250cm9scyBtYXJrZWQgd2l0aCB0aGVcclxuICogYGZpbGVzbGltaXRgIGF0dHJpYnV0ZS5cclxuICpcclxuICogIyMjIEV4YW1wbGVcclxuICpcclxuICogYGBgXHJcbiAqIDxmaWxlLXVwbG9hZCBuYW1lPVwiZmlsZXNcIiBuZ01vZGVsIGZpbGVzbGltaXQ9XCIyXCI+PC9maWxlLXVwbG9hZD5cclxuICogPGZpbGUtdXBsb2FkIG5hbWU9XCJmaWxlc1wiIG5nTW9kZWwgW2ZpbGVzbGltaXRdPVwiMlwiPjwvZmlsZS11cGxvYWQ+XHJcbiAqIGBgYFxyXG4gKlxyXG4gKi9cclxuQERpcmVjdGl2ZSh7XHJcbiAgICBzZWxlY3RvcjogJ1tmaWxlc2xpbWl0XVtmb3JtQ29udHJvbE5hbWVdLFtmaWxlc2xpbWl0XVtmb3JtQ29udHJvbF0sW2ZpbGVzbGltaXRdW25nTW9kZWxdJyxcclxuICAgIHByb3ZpZGVyczogW3tcclxuICAgICAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxyXG4gICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEZpbGVzTGltaXRWYWxpZGF0b3IpLFxyXG4gICAgICAgIG11bHRpOiB0cnVlXHJcbiAgICB9XSxcclxuICAgIGhvc3Q6IHsnW2F0dHIuZmlsZXNsaW1pdF0nOiAnZmlsZXNsaW1pdCA/IGZpbGVzbGltaXQgOiBudWxsJ31cclxufSlcclxuZXhwb3J0IGNsYXNzIEZpbGVzTGltaXRWYWxpZGF0b3IgaW1wbGVtZW50cyBWYWxpZGF0b3IsIE9uQ2hhbmdlcyB7XHJcblxyXG4gICAgQElucHV0KClcclxuICAgIHB1YmxpYyBmaWxlc2xpbWl0OiBzdHJpbmd8bnVtYmVyO1xyXG5cclxuICAgIHByaXZhdGUgdmFsaWRhdG9yOiBWYWxpZGF0b3JGbjtcclxuXHJcbiAgICBwcml2YXRlIG9uQ2hhbmdlOiAoKSA9PiB2b2lkO1xyXG5cclxuICAgIHB1YmxpYyBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCdmaWxlc2xpbWl0JyBpbiBjaGFuZ2VzKSB7XHJcbiAgICAgICAgICB0aGlzLl9jcmVhdGVWYWxpZGF0b3IoKTtcclxuICAgICAgICAgIGlmICh0aGlzLm9uQ2hhbmdlKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHZhbGlkYXRlKGM6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnN8bnVsbCB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsZXNsaW1pdCAhPSBudWxsID8gdGhpcy52YWxpZGF0b3IoYykgOiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZuOyBcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9jcmVhdGVWYWxpZGF0b3IoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy52YWxpZGF0b3IgPSBGaWxlVXBsb2FkVmFsaWRhdG9ycy5maWxlc0xpbWl0KHR5cGVvZiB0aGlzLmZpbGVzbGltaXQgPT09ICdzdHJpbmcnID8gcGFyc2VJbnQodGhpcy5maWxlc2xpbWl0LCAxMCkgOiB0aGlzLmZpbGVzbGltaXQpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQSBEaXJlY3RpdmUgdGhhdCBhZGRzIHRoZSBgYWNjZXB0YCB2YWxpZGF0b3IgdG8gY29udHJvbHMgbWFya2VkIHdpdGggdGhlXHJcbiAqIGBhY2NlcHRgIGF0dHJpYnV0ZS5cclxuICpcclxuICogIyMjIEV4YW1wbGVcclxuICpcclxuICogYGBgXHJcbiAqIDxmaWxlLXVwbG9hZCBuYW1lPVwiZmlsZXNcIiBuZ01vZGVsIGFjY2VwdD1cImZpbGVfZXh0ZW5zaW9ufGF1ZGlvLyp8dmlkZW8vKnxpbWFnZS8qfG1lZGlhX3R5cGVcIj48L2ZpbGUtdXBsb2FkPlxyXG4gKiA8ZmlsZS11cGxvYWQgbmFtZT1cImZpbGVzXCIgbmdNb2RlbCBbYWNjZXB0XT1cImZpbGVfZXh0ZW5zaW9ufGF1ZGlvLyp8dmlkZW8vKnxpbWFnZS8qfG1lZGlhX3R5cGVcIj48L2ZpbGUtdXBsb2FkPlxyXG4gKiBgYGBcclxuICogXHJcbiAqIFRvIHNwZWNpZnkgbW9yZSB0aGFuIG9uZSB2YWx1ZSwgc2VwYXJhdGUgdGhlIHZhbHVlcyB3aXRoIGEgY29tbWEgKGUuZy4gPGZpbGUtdXBsb2FkIGFjY2VwdD1cImF1ZGlvLyosdmlkZW8vKixpbWFnZS8qXCI+PC9maWxlLXVwbG9hZD4uXHJcbiAqXHJcbiAqL1xyXG5ARGlyZWN0aXZlKHtcclxuICAgIHNlbGVjdG9yOiAnW2FjY2VwdF1bZm9ybUNvbnRyb2xOYW1lXSxbYWNjZXB0XVtmb3JtQ29udHJvbF0sW2FjY2VwdF1bbmdNb2RlbF0nLFxyXG4gICAgcHJvdmlkZXJzOiBbe1xyXG4gICAgICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXHJcbiAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRmlsZXNBY2NlcHRWYWxpZGF0b3IpLFxyXG4gICAgICAgIG11bHRpOiB0cnVlXHJcbiAgICB9XSxcclxuICAgIGhvc3Q6IHsnW2F0dHIuYWNjZXB0XSc6ICdhY2NlcHQgPyBhY2NlcHQgOiBudWxsJ31cclxufSlcclxuZXhwb3J0IGNsYXNzIEZpbGVzQWNjZXB0VmFsaWRhdG9yIGltcGxlbWVudHMgVmFsaWRhdG9yLCBPbkNoYW5nZXMge1xyXG5cclxuICAgIEBJbnB1dCgpXHJcbiAgICBwdWJsaWMgYWNjZXB0OiBzdHJpbmc7XHJcblxyXG4gICAgcHJpdmF0ZSB2YWxpZGF0b3I6IFZhbGlkYXRvckZuO1xyXG5cclxuICAgIHByaXZhdGUgb25DaGFuZ2U6ICgpID0+IHZvaWQ7XHJcblxyXG4gICAgcHVibGljIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcclxuICAgICAgICBpZiAoJ2FjY2VwdCcgaW4gY2hhbmdlcykge1xyXG4gICAgICAgICAgdGhpcy5fY3JlYXRlVmFsaWRhdG9yKCk7XHJcbiAgICAgICAgICBpZiAodGhpcy5vbkNoYW5nZSkge1xyXG4gICAgICAgICAgICAgIHRoaXMub25DaGFuZ2UoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHZhbGlkYXRlKGM6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnN8bnVsbCB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWNjZXB0ICE9IG51bGwgPyB0aGlzLnZhbGlkYXRvcihjKSA6IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZm46ICgpID0+IHZvaWQpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZm47XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfY3JlYXRlVmFsaWRhdG9yKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMudmFsaWRhdG9yID0gRmlsZVVwbG9hZFZhbGlkYXRvcnMuYWNjZXB0KHRoaXMuYWNjZXB0LnNwbGl0KCcsJykpO1xyXG4gICAgfVxyXG59XHJcbiJdfQ==