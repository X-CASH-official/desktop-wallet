/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injectable, PLATFORM_ID, Inject } from '@angular/core';
import { DOCUMENT } from '@angular/common';
import { isPlatformBrowser } from '@angular/common';
import { ScrollToAnimation } from './scroll-to-animation';
import { stripHash, isString, isNumber, isElementRef, isWindow, DEFAULTS, isNativeElement } from './scroll-to-helpers';
import { ReplaySubject, throwError } from 'rxjs/index';
/**
 * The Scroll To Service handles starting, interrupting
 * and ending the actual Scroll Animation. It provides
 * some utilities to find the proper HTML Element on a
 * given page to setup Event Listeners and calculate
 * distances for the Animation.
 */
var ScrollToService = /** @class */ (function () {
    /**
     * Construct and setup required paratemeters.
     *
     * @param _document         A Reference to the Document
     * @param _platformId       Angular Platform ID
     */
    function ScrollToService(_document, _platformId) {
        this._document = _document;
        this._platformId = _platformId;
        this._interruptiveEvents = ['mousewheel', 'DOMMouseScroll', 'touchstart'];
    }
    /**
     * Target an Element to scroll to. Notice that the `TimeOut` decorator
     * ensures the executing to take place in the next Angular lifecycle.
     * This allows for scrolling to elements that are e.g. initially hidden
     * by means of `*ngIf`, but ought to be scrolled to eventually.
     *
     * \@todo type 'any' in Observable should become custom type like 'ScrollToEvent' (base class), see issue comment:
     * 	- https://github.com/nicky-lenaers/ngx-scroll-to/issues/10#issuecomment-317198481
     *
     * @param {?} options         Configuration Object
     * @return {?} Observable
     */
    ScrollToService.prototype.scrollTo = /**
     * Target an Element to scroll to. Notice that the `TimeOut` decorator
     * ensures the executing to take place in the next Angular lifecycle.
     * This allows for scrolling to elements that are e.g. initially hidden
     * by means of `*ngIf`, but ought to be scrolled to eventually.
     *
     * \@todo type 'any' in Observable should become custom type like 'ScrollToEvent' (base class), see issue comment:
     * 	- https://github.com/nicky-lenaers/ngx-scroll-to/issues/10#issuecomment-317198481
     *
     * @param {?} options         Configuration Object
     * @return {?} Observable
     */
    function (options) {
        if (!isPlatformBrowser(this._platformId))
            return new ReplaySubject().asObservable();
        return this._start(options);
    };
    /**
     * Start a new Animation.
     *
     * \@todo Emit proper events from subscription
     *
     * @param {?} options         Configuration Object
     * @return {?} Observable
     */
    ScrollToService.prototype._start = /**
     * Start a new Animation.
     *
     * \@todo Emit proper events from subscription
     *
     * @param {?} options         Configuration Object
     * @return {?} Observable
     */
    function (options) {
        var _this = this;
        // Merge config with default values
        var /** @type {?} */ mergedConfigOptions = /** @type {?} */ (tslib_1.__assign({}, /** @type {?} */ (DEFAULTS), options));
        if (this._animation)
            this._animation.stop();
        var /** @type {?} */ targetNode = this._getNode(mergedConfigOptions.target);
        if (mergedConfigOptions.target && !targetNode)
            return throwError('Unable to find Target Element');
        var /** @type {?} */ container = this._getContainer(mergedConfigOptions, targetNode);
        if (mergedConfigOptions.container && !container)
            return throwError('Unable to find Container Element');
        var /** @type {?} */ listenerTarget = this._getListenerTarget(container) || window;
        var /** @type {?} */ to = container ? container.getBoundingClientRect().top : 0;
        if (targetNode) {
            to = isWindow(listenerTarget) ? targetNode.offsetTop : targetNode.getBoundingClientRect().top;
        }
        // Create Animation
        this._animation = new ScrollToAnimation(container, listenerTarget, isWindow(listenerTarget), to, mergedConfigOptions, isPlatformBrowser(this._platformId));
        var /** @type {?} */ onInterrupt = function () { return _this._animation.stop(); };
        this._addInterruptiveEventListeners(listenerTarget, onInterrupt);
        // Start Animation
        var /** @type {?} */ animation$ = this._animation.start();
        this._subscribeToAnimation(animation$, listenerTarget, onInterrupt);
        return animation$;
    };
    /**
     * Subscribe to the events emitted from the Scrolling
     * Animation. Events might be used for e.g. unsubscribing
     * once finished.
     *
     * @param {?} animation$              The Animation Observable
     * @param {?} listenerTarget          The Listener Target for events
     * @param {?} onInterrupt             The handler for Interruptive Events
     * @return {?} Void
     */
    ScrollToService.prototype._subscribeToAnimation = /**
     * Subscribe to the events emitted from the Scrolling
     * Animation. Events might be used for e.g. unsubscribing
     * once finished.
     *
     * @param {?} animation$              The Animation Observable
     * @param {?} listenerTarget          The Listener Target for events
     * @param {?} onInterrupt             The handler for Interruptive Events
     * @return {?} Void
     */
    function (animation$, listenerTarget, onInterrupt) {
        var _this = this;
        var /** @type {?} */ subscription = animation$
            .subscribe(function () { }, function () { }, function () {
            _this._removeInterruptiveEventListeners(_this._interruptiveEvents, listenerTarget, onInterrupt);
            subscription.unsubscribe();
        });
    };
    /**
     * Get the container HTML Element in which
     * the scrolling should happen.
     *
     * @param {?} options         The Merged Configuration Object
     * @param {?} targetNode    the targeted HTMLElement
     * @return {?}
     */
    ScrollToService.prototype._getContainer = /**
     * Get the container HTML Element in which
     * the scrolling should happen.
     *
     * @param {?} options         The Merged Configuration Object
     * @param {?} targetNode    the targeted HTMLElement
     * @return {?}
     */
    function (options, targetNode) {
        var /** @type {?} */ container = null;
        if (options.container) {
            container = this._getNode(options.container, true);
        }
        else if (targetNode) {
            container = this._getFirstScrollableParent(targetNode);
        }
        return container;
    };
    /**
     * Add listeners for the Animation Interruptive Events
     * to the Listener Target.
     *
     * @param {?} listenerTarget    Target to attach the listener on
     * @param {?} handler           Handler for when the listener fires
     * @return {?} Void
     */
    ScrollToService.prototype._addInterruptiveEventListeners = /**
     * Add listeners for the Animation Interruptive Events
     * to the Listener Target.
     *
     * @param {?} listenerTarget    Target to attach the listener on
     * @param {?} handler           Handler for when the listener fires
     * @return {?} Void
     */
    function (listenerTarget, handler) {
        var _this = this;
        if (!listenerTarget)
            listenerTarget = window;
        this._interruptiveEvents
            .forEach(function (event) { return listenerTarget
            .addEventListener(event, handler, _this._supportPassive() ? { passive: true } : false); });
    };
    /**
     * Feature-detect support for passive event listeners.
     *
     * @return {?} Whether or not passive event listeners are supported
     */
    ScrollToService.prototype._supportPassive = /**
     * Feature-detect support for passive event listeners.
     *
     * @return {?} Whether or not passive event listeners are supported
     */
    function () {
        var /** @type {?} */ supportsPassive = false;
        try {
            var /** @type {?} */ opts = Object.defineProperty({}, 'passive', {
                get: function () {
                    supportsPassive = true;
                }
            });
            window.addEventListener('testPassive', null, opts);
            window.removeEventListener('testPassive', null, opts);
        }
        catch (/** @type {?} */ e) { }
        return supportsPassive;
    };
    /**
     * Remove listeners for the Animation Interrupt Event from
     * the Listener Target. Specifying the correct handler prevents
     * memory leaks and makes the allocated memory available for
     * Garbage Collection.
     *
     * @param {?} events            List of Interruptive Events to remove
     * @param {?} listenerTarget    Target to attach the listener on
     * @param {?} handler           Handler for when the listener fires
     * @return {?} Void
     */
    ScrollToService.prototype._removeInterruptiveEventListeners = /**
     * Remove listeners for the Animation Interrupt Event from
     * the Listener Target. Specifying the correct handler prevents
     * memory leaks and makes the allocated memory available for
     * Garbage Collection.
     *
     * @param {?} events            List of Interruptive Events to remove
     * @param {?} listenerTarget    Target to attach the listener on
     * @param {?} handler           Handler for when the listener fires
     * @return {?} Void
     */
    function (events, listenerTarget, handler) {
        if (!listenerTarget)
            listenerTarget = window;
        events.forEach(function (event) { return listenerTarget.removeEventListener(event, handler); });
    };
    /**
     * Find the first scrollable parent Node of a given
     * Element. The DOM Tree gets searched upwards
     * to find this first scrollable parent. Parents might
     * be ignored by CSS styles applied to the HTML Element.
     *
     * @param {?} nativeElement     The Element to search the DOM Tree upwards from
     * @return {?} The first scrollable parent HTML Element
     */
    ScrollToService.prototype._getFirstScrollableParent = /**
     * Find the first scrollable parent Node of a given
     * Element. The DOM Tree gets searched upwards
     * to find this first scrollable parent. Parents might
     * be ignored by CSS styles applied to the HTML Element.
     *
     * @param {?} nativeElement     The Element to search the DOM Tree upwards from
     * @return {?} The first scrollable parent HTML Element
     */
    function (nativeElement) {
        var /** @type {?} */ style = window.getComputedStyle(nativeElement);
        var /** @type {?} */ overflowRegex = /(auto|scroll|overlay)/;
        if (style.position === 'fixed')
            return null;
        for (var /** @type {?} */ parent_1 = nativeElement; parent_1 = parent_1.parentElement; null) {
            style = window.getComputedStyle(parent_1);
            if (style.position === 'absolute'
                || style.overflow === 'hidden'
                || style.overflowY === 'hidden')
                continue;
            if (overflowRegex.test(style.overflow + style.overflowY)
                || parent_1.tagName === 'BODY')
                return parent_1;
        }
        return null;
    };
    /**
     * Get the Target Node to scroll to.
     *
     * @param {?} id              The given ID of the node, either a string or
     *                        an element reference
     * @param {?=} allowBodyTag    Indicate whether or not the Document Body is
     *                        considered a valid Target Node
     * @return {?} The Target Node to scroll to
     */
    ScrollToService.prototype._getNode = /**
     * Get the Target Node to scroll to.
     *
     * @param {?} id              The given ID of the node, either a string or
     *                        an element reference
     * @param {?=} allowBodyTag    Indicate whether or not the Document Body is
     *                        considered a valid Target Node
     * @return {?} The Target Node to scroll to
     */
    function (id, allowBodyTag) {
        if (allowBodyTag === void 0) { allowBodyTag = false; }
        var /** @type {?} */ targetNode;
        if (isString(id)) {
            if (allowBodyTag && (id === 'body' || id === 'BODY')) {
                targetNode = this._document.body;
            }
            else {
                targetNode = this._document.getElementById(stripHash(id));
            }
        }
        else if (isNumber(id)) {
            targetNode = this._document.getElementById(String(id));
        }
        else if (isElementRef(id)) {
            targetNode = id.nativeElement;
        }
        else if (isNativeElement(id)) {
            targetNode = id;
        }
        return targetNode;
    };
    /**
     * Retrieve the Listener target. This Listener Target is used
     * to attach Event Listeners on. In case of the target being
     * the Document Body, we need the actual `window` to listen
     * for events.
     *
     * @param {?} container           The HTML Container element
     * @return {?} The Listener Target to attach events on
     */
    ScrollToService.prototype._getListenerTarget = /**
     * Retrieve the Listener target. This Listener Target is used
     * to attach Event Listeners on. In case of the target being
     * the Document Body, we need the actual `window` to listen
     * for events.
     *
     * @param {?} container           The HTML Container element
     * @return {?} The Listener Target to attach events on
     */
    function (container) {
        if (!container)
            return null;
        return this._isDocumentBody(container) ? window : container;
    };
    /**
     * Test if a given HTML Element is the Document Body.
     *
     * @param {?} element             The given HTML Element
     * @return {?} Whether or not the Element is the
     *                            Document Body Element
     */
    ScrollToService.prototype._isDocumentBody = /**
     * Test if a given HTML Element is the Document Body.
     *
     * @param {?} element             The given HTML Element
     * @return {?} Whether or not the Element is the
     *                            Document Body Element
     */
    function (element) {
        return element.tagName.toUpperCase() === 'BODY';
    };
    ScrollToService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    ScrollToService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
    ]; };
    return ScrollToService;
}());
export { ScrollToService };
function ScrollToService_tsickle_Closure_declarations() {
    /**
     * The animation that provides the scrolling
     * to happen smoothly over time. Defining it here
     * allows for usage of e.g. `start` and `stop`
     * methods within this Angular Service.
     * @type {?}
     */
    ScrollToService.prototype._animation;
    /**
     * Interruptive Events allow to scrolling animation
     * to be interrupted before it is finished. The list
     * of Interruptive Events represents those.
     * @type {?}
     */
    ScrollToService.prototype._interruptiveEvents;
    /** @type {?} */
    ScrollToService.prototype._document;
    /** @type {?} */
    ScrollToService.prototype._platformId;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2Nyb2xsLXRvLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Abmlja3ktbGVuYWVycy9uZ3gtc2Nyb2xsLXRvLyIsInNvdXJjZXMiOlsic3JjL2FwcC9tb2R1bGVzL3Njcm9sbC10by9zY3JvbGwtdG8uc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNoRSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDM0MsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFRcEQsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDMUQsT0FBTyxFQUNMLFNBQVMsRUFDVCxRQUFRLEVBQ1IsUUFBUSxFQUNSLFlBQVksRUFDWixRQUFRLEVBQ1IsUUFBUSxFQUNSLGVBQWUsRUFDaEIsTUFBTSxxQkFBcUIsQ0FBQztBQUM3QixPQUFPLEVBQWMsYUFBYSxFQUFFLFVBQVUsRUFBRSxNQUFNLFlBQVksQ0FBQzs7Ozs7Ozs7O0lBMkJqRTs7Ozs7T0FLRztJQUNILHlCQUM0QixTQUFjLEVBQ1gsV0FBZ0I7UUFEbkIsY0FBUyxHQUFULFNBQVMsQ0FBSztRQUNYLGdCQUFXLEdBQVgsV0FBVyxDQUFLO1FBRTdDLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxDQUFDLFlBQVksRUFBRSxnQkFBZ0IsRUFBRSxZQUFZLENBQUMsQ0FBQztLQUMzRTs7Ozs7Ozs7Ozs7OztJQWNNLGtDQUFROzs7Ozs7Ozs7Ozs7Y0FBQyxPQUE4QjtRQUU1QyxFQUFFLENBQUMsQ0FBQyxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUFDLE1BQU0sQ0FBQyxJQUFJLGFBQWEsRUFBRSxDQUFDLFlBQVksRUFBRSxDQUFDO1FBRXBGLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxD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QUFTLENBQUM7Ozs7Ozs7OztJQVV0RCx5Q0FBZTs7Ozs7OztjQUFDLE9BQW9CO1FBQzFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLFdBQVcsRUFBRSxLQUFLLE1BQU0sQ0FBQzs7O2dCQXRTbkQsVUFBVTs7OztnREF5Qk4sTUFBTSxTQUFDLFFBQVE7Z0RBQ2YsTUFBTSxTQUFDLFdBQVc7OzBCQXZEdkI7O1NBOEJhLGVBQWUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBQTEFURk9STV9JRCwgSW5qZWN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHsgaXNQbGF0Zm9ybUJyb3dzZXIgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5cclxuaW1wb3J0IHtcclxuICBTY3JvbGxUb0NvbmZpZ09wdGlvbnMsXHJcbiAgU2Nyb2xsVG9UYXJnZXQsXHJcbiAgU2Nyb2xsVG9MaXN0ZW5lclRhcmdldCxcclxuICBTY3JvbGxUb0NvbmZpZ09wdGlvbnNUYXJnZXRcclxufSBmcm9tICcuL3Njcm9sbC10by1jb25maWcuaW50ZXJmYWNlJztcclxuaW1wb3J0IHsgU2Nyb2xsVG9BbmltYXRpb24gfSBmcm9tICcuL3Njcm9sbC10by1hbmltYXRpb24nO1xyXG5pbXBvcnQge1xyXG4gIHN0cmlwSGFzaCxcclxuICBpc1N0cmluZyxcclxuICBpc051bWJlcixcclxuICBpc0VsZW1lbnRSZWYsXHJcbiAgaXNXaW5kb3csXHJcbiAgREVGQVVMVFMsXHJcbiAgaXNOYXRpdmVFbGVtZW50XHJcbn0gZnJvbSAnLi9zY3JvbGwtdG8taGVscGVycyc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUsIFJlcGxheVN1YmplY3QsIHRocm93RXJyb3IgfSBmcm9tICdyeGpzL2luZGV4JztcclxuXHJcbi8qKlxyXG4gKiBUaGUgU2Nyb2xsIFRvIFNlcnZpY2UgaGFuZGxlcyBzdGFydGluZywgaW50ZXJydXB0aW5nXHJcbiAqIGFuZCBlbmRpbmcgdGhlIGFjdHVhbCBTY3JvbGwgQW5pbWF0aW9uLiBJdCBwcm92aWRlc1xyXG4gKiBzb21lIHV0aWxpdGllcyB0byBmaW5kIHRoZSBwcm9wZXIgSFRNTCBFbGVtZW50IG9uIGFcclxuICogZ2l2ZW4gcGFnZSB0byBzZXR1cCBFdmVudCBMaXN0ZW5lcnMgYW5kIGNhbGN1bGF0ZVxyXG4gKiBkaXN0YW5jZXMgZm9yIHRoZSBBbmltYXRpb24uXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBTY3JvbGxUb1NlcnZpY2Uge1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgYW5pbWF0aW9uIHRoYXQgcHJvdmlkZXMgdGhlIHNjcm9sbGluZ1xyXG4gICAqIHRvIGhhcHBlbiBzbW9vdGhseSBvdmVyIHRpbWUuIERlZmluaW5nIGl0IGhlcmVcclxuICAgKiBhbGxvd3MgZm9yIHVzYWdlIG9mIGUuZy4gYHN0YXJ0YCBhbmQgYHN0b3BgXHJcbiAgICogbWV0aG9kcyB3aXRoaW4gdGhpcyBBbmd1bGFyIFNlcnZpY2UuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfYW5pbWF0aW9uOiBTY3JvbGxUb0FuaW1hdGlvbjtcclxuXHJcbiAgLyoqXHJcbiAgICogSW50ZXJydXB0aXZlIEV2ZW50cyBhbGxvdyB0byBzY3JvbGxpbmcgYW5pbWF0aW9uXHJcbiAgICogdG8gYmUgaW50ZXJydXB0ZWQgYmVmb3JlIGl0IGlzIGZpbmlzaGVkLiBUaGUgbGlzdFxyXG4gICAqIG9mIEludGVycnVwdGl2ZSBFdmVudHMgcmVwcmVzZW50cyB0aG9zZS5cclxuICAgKi9cclxuICBwcml2YXRlIF9pbnRlcnJ1cHRpdmVFdmVudHM6IHN0cmluZ1tdO1xyXG5cclxuICAvKipcclxuICAgKiBDb25zdHJ1Y3QgYW5kIHNldHVwIHJlcXVpcmVkIHBhcmF0ZW1ldGVycy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBfZG9jdW1lbnQgICAgICAgICBBIFJlZmVyZW5jZSB0byB0aGUgRG9jdW1lbnRcclxuICAgKiBAcGFyYW0gX3BsYXRmb3JtSWQgICAgICAgQW5ndWxhciBQbGF0Zm9ybSBJRFxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgQEluamVjdChET0NVTUVOVCkgcHJpdmF0ZSBfZG9jdW1lbnQ6IGFueSxcclxuICAgIEBJbmplY3QoUExBVEZPUk1fSUQpIHByaXZhdGUgX3BsYXRmb3JtSWQ6IGFueVxyXG4gICkge1xyXG4gICAgdGhpcy5faW50ZXJydXB0aXZlRXZlbnRzID0gWydtb3VzZXdoZWVsJywgJ0RPTU1vdXNlU2Nyb2xsJywgJ3RvdWNoc3RhcnQnXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRhcmdldCBhbiBFbGVtZW50IHRvIHNjcm9sbCB0by4gTm90aWNlIHRoYXQgdGhlIGBUaW1lT3V0YCBkZWNvcmF0b3JcclxuICAgKiBlbnN1cmVzIHRoZSBleGVjdXRpbmcgdG8gdGFrZSBwbGFjZSBpbiB0aGUgbmV4dCBBbmd1bGFyIGxpZmVjeWNsZS5cclxuICAgKiBUaGlzIGFsbG93cyBmb3Igc2Nyb2xsaW5nIHRvIGVsZW1lbnRzIHRoYXQgYXJlIGUuZy4gaW5pdGlhbGx5IGhpZGRlblxyXG4gICAqIGJ5IG1lYW5zIG9mIGAqbmdJZmAsIGJ1dCBvdWdodCB0byBiZSBzY3JvbGxlZCB0byBldmVudHVhbGx5LlxyXG4gICAqXHJcbiAgICogQHRvZG8gdHlwZSAnYW55JyBpbiBPYnNlcnZhYmxlIHNob3VsZCBiZWNvbWUgY3VzdG9tIHR5cGUgbGlrZSAnU2Nyb2xsVG9FdmVudCcgKGJhc2UgY2xhc3MpLCBzZWUgaXNzdWUgY29tbWVudDpcclxuICAgKiBcdC0gaHR0cHM6Ly9naXRodWIuY29tL25pY2t5LWxlbmFlcnMvbmd4LXNjcm9sbC10by9pc3N1ZXMvMTAjaXNzdWVjb21tZW50LTMxNzE5ODQ4MVxyXG4gICAqXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgICAgICAgICBDb25maWd1cmF0aW9uIE9iamVjdFxyXG4gICAqIEByZXR1cm5zICAgICAgICAgICAgICAgT2JzZXJ2YWJsZVxyXG4gICAqL1xyXG4gIHB1YmxpYyBzY3JvbGxUbyhvcHRpb25zOiBTY3JvbGxUb0NvbmZpZ09wdGlvbnMpOiBPYnNlcnZhYmxlPGFueT4ge1xyXG5cclxuICAgIGlmICghaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5fcGxhdGZvcm1JZCkpIHJldHVybiBuZXcgUmVwbGF5U3ViamVjdCgpLmFzT2JzZXJ2YWJsZSgpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLl9zdGFydChvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0IGEgbmV3IEFuaW1hdGlvbi5cclxuICAgKlxyXG4gICAqIEB0b2RvIEVtaXQgcHJvcGVyIGV2ZW50cyBmcm9tIHN1YnNjcmlwdGlvblxyXG4gICAqXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgICAgICAgICBDb25maWd1cmF0aW9uIE9iamVjdFxyXG4gICAqIEByZXR1cm5zICAgICAgICAgICAgICAgT2JzZXJ2YWJsZVxyXG4gICAqL1xyXG4gIHByaXZhdGUgX3N0YXJ0KG9wdGlvbnM6IFNjcm9sbFRvQ29uZmlnT3B0aW9ucyk6IE9ic2VydmFibGU8bnVtYmVyPiB7XHJcblxyXG4gICAgLy8gTWVyZ2UgY29uZmlnIHdpdGggZGVmYXVsdCB2YWx1ZXNcclxuICAgIGNvbnN0IG1lcmdlZENvbmZpZ09wdGlvbnMgPSB7XHJcbiAgICAgIC4uLkRFRkFVTFRTIGFzIFNjcm9sbFRvQ29uZmlnT3B0aW9ucyxcclxuICAgICAgLi4ub3B0aW9uc1xyXG4gICAgfSBhcyBTY3JvbGxUb0NvbmZpZ09wdGlvbnNUYXJnZXQ7XHJcblxyXG4gICAgaWYgKHRoaXMuX2FuaW1hdGlvbikgdGhpcy5fYW5pbWF0aW9uLnN0b3AoKTtcclxuXHJcbiAgICBjb25zdCB0YXJnZXROb2RlID0gdGhpcy5fZ2V0Tm9kZShtZXJnZWRDb25maWdPcHRpb25zLnRhcmdldCk7XHJcbiAgICBpZiAobWVyZ2VkQ29uZmlnT3B0aW9ucy50YXJnZXQgJiYgIXRhcmdldE5vZGUpIHJldHVybiB0aHJvd0Vycm9yKCdVbmFibGUgdG8gZmluZCBUYXJnZXQgRWxlbWVudCcpO1xyXG5cclxuICAgIGNvbnN0IGNvbnRhaW5lcjogSFRNTEVsZW1lbnQgPSB0aGlzLl9nZXRDb250YWluZXIobWVyZ2VkQ29uZmlnT3B0aW9ucywgdGFyZ2V0Tm9kZSk7XHJcbiAgICBpZiAobWVyZ2VkQ29uZmlnT3B0aW9ucy5jb250YWluZXIgJiYgIWNvbnRhaW5lcikgcmV0dXJuIHRocm93RXJyb3IoJ1VuYWJsZSB0byBmaW5kIENvbnRhaW5lciBFbGVtZW50Jyk7XHJcblxyXG4gICAgY29uc3QgbGlzdGVuZXJUYXJnZXQgPSB0aGlzLl9nZXRMaXN0ZW5lclRhcmdldChjb250YWluZXIpIHx8IHdpbmRvdztcclxuXHJcbiAgICBsZXQgdG8gPSBjb250YWluZXIgPyBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIDogMDtcclxuXHJcbiAgICBpZiAodGFyZ2V0Tm9kZSkge1xyXG4gICAgICB0byA9IGlzV2luZG93KGxpc3RlbmVyVGFyZ2V0KSA/IHRhcmdldE5vZGUub2Zmc2V0VG9wIDogdGFyZ2V0Tm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ3JlYXRlIEFuaW1hdGlvblxyXG4gICAgdGhpcy5fYW5pbWF0aW9uID0gbmV3IFNjcm9sbFRvQW5pbWF0aW9uKFxyXG4gICAgICBjb250YWluZXIsXHJcbiAgICAgIGxpc3RlbmVyVGFyZ2V0LFxyXG4gICAgICBpc1dpbmRvdyhsaXN0ZW5lclRhcmdldCksXHJcbiAgICAgIHRvLFxyXG4gICAgICBtZXJnZWRDb25maWdPcHRpb25zLFxyXG4gICAgICBpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLl9wbGF0Zm9ybUlkKVxyXG4gICAgKTtcclxuICAgIGNvbnN0IG9uSW50ZXJydXB0ID0gKCkgPT4gdGhpcy5fYW5pbWF0aW9uLnN0b3AoKTtcclxuICAgIHRoaXMuX2FkZEludGVycnVwdGl2ZUV2ZW50TGlzdGVuZXJzKGxpc3RlbmVyVGFyZ2V0LCBvbkludGVycnVwdCk7XHJcblxyXG4gICAgLy8gU3RhcnQgQW5pbWF0aW9uXHJcbiAgICBjb25zdCBhbmltYXRpb24kID0gdGhpcy5fYW5pbWF0aW9uLnN0YXJ0KCk7XHJcbiAgICB0aGlzLl9zdWJzY3JpYmVUb0FuaW1hdGlvbihhbmltYXRpb24kLCBsaXN0ZW5lclRhcmdldCwgb25JbnRlcnJ1cHQpO1xyXG5cclxuICAgIHJldHVybiBhbmltYXRpb24kO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3Vic2NyaWJlIHRvIHRoZSBldmVudHMgZW1pdHRlZCBmcm9tIHRoZSBTY3JvbGxpbmdcclxuICAgKiBBbmltYXRpb24uIEV2ZW50cyBtaWdodCBiZSB1c2VkIGZvciBlLmcuIHVuc3Vic2NyaWJpbmdcclxuICAgKiBvbmNlIGZpbmlzaGVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGFuaW1hdGlvbiQgICAgICAgICAgICAgIFRoZSBBbmltYXRpb24gT2JzZXJ2YWJsZVxyXG4gICAqIEBwYXJhbSBsaXN0ZW5lclRhcmdldCAgICAgICAgICBUaGUgTGlzdGVuZXIgVGFyZ2V0IGZvciBldmVudHNcclxuICAgKiBAcGFyYW0gb25JbnRlcnJ1cHQgICAgICAgICAgICAgVGhlIGhhbmRsZXIgZm9yIEludGVycnVwdGl2ZSBFdmVudHNcclxuICAgKiBAcmV0dXJucyAgICAgICAgICAgICAgICAgICAgICAgVm9pZFxyXG4gICAqL1xyXG4gIHByaXZhdGUgX3N1YnNjcmliZVRvQW5pbWF0aW9uKFxyXG4gICAgYW5pbWF0aW9uJDogT2JzZXJ2YWJsZTxhbnk+LFxyXG4gICAgbGlzdGVuZXJUYXJnZXQ6IFNjcm9sbFRvTGlzdGVuZXJUYXJnZXQsXHJcbiAgICBvbkludGVycnVwdDogRXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdFxyXG4gICkge1xyXG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gYW5pbWF0aW9uJFxyXG4gICAgICAuc3Vic2NyaWJlKFxyXG4gICAgICAgICgpID0+IHsgfSxcclxuICAgICAgICAoKSA9PiB7IH0sXHJcbiAgICAgICAgKCkgPT4ge1xyXG4gICAgICAgICAgdGhpcy5fcmVtb3ZlSW50ZXJydXB0aXZlRXZlbnRMaXN0ZW5lcnModGhpcy5faW50ZXJydXB0aXZlRXZlbnRzLCBsaXN0ZW5lclRhcmdldCwgb25JbnRlcnJ1cHQpO1xyXG4gICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBjb250YWluZXIgSFRNTCBFbGVtZW50IGluIHdoaWNoXHJcbiAgICogdGhlIHNjcm9sbGluZyBzaG91bGQgaGFwcGVuLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgICAgICAgICBUaGUgTWVyZ2VkIENvbmZpZ3VyYXRpb24gT2JqZWN0XHJcbiAgICogQHBhcmFtIHRhcmdldE5vZGUgICAgdGhlIHRhcmdldGVkIEhUTUxFbGVtZW50XHJcbiAgICogQHJldHVybnNcclxuICAgKi9cclxuICBwcml2YXRlIF9nZXRDb250YWluZXIob3B0aW9uczogU2Nyb2xsVG9Db25maWdPcHRpb25zLCB0YXJnZXROb2RlOiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50IHwgbnVsbCB7XHJcblxyXG4gICAgbGV0IGNvbnRhaW5lcjogSFRNTEVsZW1lbnQgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgICBpZiAob3B0aW9ucy5jb250YWluZXIpIHtcclxuICAgICAgY29udGFpbmVyID0gdGhpcy5fZ2V0Tm9kZShvcHRpb25zLmNvbnRhaW5lciwgdHJ1ZSk7XHJcbiAgICB9IGVsc2UgaWYgKHRhcmdldE5vZGUpIHtcclxuICAgICAgY29udGFpbmVyID0gdGhpcy5fZ2V0Rmlyc3RTY3JvbGxhYmxlUGFyZW50KHRhcmdldE5vZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjb250YWluZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGQgbGlzdGVuZXJzIGZvciB0aGUgQW5pbWF0aW9uIEludGVycnVwdGl2ZSBFdmVudHNcclxuICAgKiB0byB0aGUgTGlzdGVuZXIgVGFyZ2V0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGV2ZW50cyAgICAgICAgICAgIExpc3Qgb2YgZXZlbnRzIHRvIGxpc3RlbiB0b1xyXG4gICAqIEBwYXJhbSBsaXN0ZW5lclRhcmdldCAgICBUYXJnZXQgdG8gYXR0YWNoIHRoZSBsaXN0ZW5lciBvblxyXG4gICAqIEBwYXJhbSBoYW5kbGVyICAgICAgICAgICBIYW5kbGVyIGZvciB3aGVuIHRoZSBsaXN0ZW5lciBmaXJlc1xyXG4gICAqIEByZXR1cm5zICAgICAgICAgICAgICAgICBWb2lkXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfYWRkSW50ZXJydXB0aXZlRXZlbnRMaXN0ZW5lcnMoXHJcbiAgICBsaXN0ZW5lclRhcmdldDogU2Nyb2xsVG9MaXN0ZW5lclRhcmdldCxcclxuICAgIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3QpOiB2b2lkIHtcclxuXHJcbiAgICBpZiAoIWxpc3RlbmVyVGFyZ2V0KSBsaXN0ZW5lclRhcmdldCA9IHdpbmRvdztcclxuXHJcbiAgICB0aGlzLl9pbnRlcnJ1cHRpdmVFdmVudHNcclxuICAgICAgLmZvckVhY2goZXZlbnQgPT4gbGlzdGVuZXJUYXJnZXRcclxuICAgICAgICAuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgdGhpcy5fc3VwcG9ydFBhc3NpdmUoKSA/IHsgcGFzc2l2ZTogdHJ1ZSB9IDogZmFsc2UpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZlYXR1cmUtZGV0ZWN0IHN1cHBvcnQgZm9yIHBhc3NpdmUgZXZlbnQgbGlzdGVuZXJzLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMgICAgICAgV2hldGhlciBvciBub3QgcGFzc2l2ZSBldmVudCBsaXN0ZW5lcnMgYXJlIHN1cHBvcnRlZFxyXG4gICAqL1xyXG4gIHByaXZhdGUgX3N1cHBvcnRQYXNzaXZlKCk6IGJvb2xlYW4ge1xyXG5cclxuICAgIGxldCBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3RQYXNzaXZlJywgbnVsbCwgb3B0cyk7XHJcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0UGFzc2l2ZScsIG51bGwsIG9wdHMpO1xyXG4gICAgfSBjYXRjaCAoZSkgeyB9XHJcblxyXG4gICAgcmV0dXJuIHN1cHBvcnRzUGFzc2l2ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSBsaXN0ZW5lcnMgZm9yIHRoZSBBbmltYXRpb24gSW50ZXJydXB0IEV2ZW50IGZyb21cclxuICAgKiB0aGUgTGlzdGVuZXIgVGFyZ2V0LiBTcGVjaWZ5aW5nIHRoZSBjb3JyZWN0IGhhbmRsZXIgcHJldmVudHNcclxuICAgKiBtZW1vcnkgbGVha3MgYW5kIG1ha2VzIHRoZSBhbGxvY2F0ZWQgbWVtb3J5IGF2YWlsYWJsZSBmb3JcclxuICAgKiBHYXJiYWdlIENvbGxlY3Rpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gZXZlbnRzICAgICAgICAgICAgTGlzdCBvZiBJbnRlcnJ1cHRpdmUgRXZlbnRzIHRvIHJlbW92ZVxyXG4gICAqIEBwYXJhbSBsaXN0ZW5lclRhcmdldCAgICBUYXJnZXQgdG8gYXR0YWNoIHRoZSBsaXN0ZW5lciBvblxyXG4gICAqIEBwYXJhbSBoYW5kbGVyICAgICAgICAgICBIYW5kbGVyIGZvciB3aGVuIHRoZSBsaXN0ZW5lciBmaXJlc1xyXG4gICAqIEByZXR1cm5zICAgICAgICAgICAgICAgICBWb2lkXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfcmVtb3ZlSW50ZXJydXB0aXZlRXZlbnRMaXN0ZW5lcnMoXHJcbiAgICBldmVudHM6IHN0cmluZ1tdLFxyXG4gICAgbGlzdGVuZXJUYXJnZXQ6IFNjcm9sbFRvTGlzdGVuZXJUYXJnZXQsXHJcbiAgICBoYW5kbGVyOiBFdmVudExpc3RlbmVyT3JFdmVudExpc3RlbmVyT2JqZWN0KTogdm9pZCB7XHJcblxyXG4gICAgaWYgKCFsaXN0ZW5lclRhcmdldCkgbGlzdGVuZXJUYXJnZXQgPSB3aW5kb3c7XHJcbiAgICBldmVudHMuZm9yRWFjaChldmVudCA9PiBsaXN0ZW5lclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGaW5kIHRoZSBmaXJzdCBzY3JvbGxhYmxlIHBhcmVudCBOb2RlIG9mIGEgZ2l2ZW5cclxuICAgKiBFbGVtZW50LiBUaGUgRE9NIFRyZWUgZ2V0cyBzZWFyY2hlZCB1cHdhcmRzXHJcbiAgICogdG8gZmluZCB0aGlzIGZpcnN0IHNjcm9sbGFibGUgcGFyZW50LiBQYXJlbnRzIG1pZ2h0XHJcbiAgICogYmUgaWdub3JlZCBieSBDU1Mgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIEhUTUwgRWxlbWVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBuYXRpdmVFbGVtZW50ICAgICBUaGUgRWxlbWVudCB0byBzZWFyY2ggdGhlIERPTSBUcmVlIHVwd2FyZHMgZnJvbVxyXG4gICAqIEByZXR1cm5zICAgICAgICAgICAgICAgICBUaGUgZmlyc3Qgc2Nyb2xsYWJsZSBwYXJlbnQgSFRNTCBFbGVtZW50XHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfZ2V0Rmlyc3RTY3JvbGxhYmxlUGFyZW50KG5hdGl2ZUVsZW1lbnQ6IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnQge1xyXG5cclxuICAgIGxldCBzdHlsZTogQ1NTU3R5bGVEZWNsYXJhdGlvbiA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5hdGl2ZUVsZW1lbnQpO1xyXG5cclxuICAgIGNvbnN0IG92ZXJmbG93UmVnZXg6IFJlZ0V4cCA9IC8oYXV0b3xzY3JvbGx8b3ZlcmxheSkvO1xyXG5cclxuICAgIGlmIChzdHlsZS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgZm9yIChsZXQgcGFyZW50ID0gbmF0aXZlRWxlbWVudDsgcGFyZW50ID0gcGFyZW50LnBhcmVudEVsZW1lbnQ7IG51bGwpIHtcclxuXHJcbiAgICAgIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUocGFyZW50KTtcclxuXHJcbiAgICAgIGlmIChzdHlsZS5wb3NpdGlvbiA9PT0gJ2Fic29sdXRlJ1xyXG4gICAgICAgIHx8IHN0eWxlLm92ZXJmbG93ID09PSAnaGlkZGVuJ1xyXG4gICAgICAgIHx8IHN0eWxlLm92ZXJmbG93WSA9PT0gJ2hpZGRlbicpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgaWYgKG92ZXJmbG93UmVnZXgudGVzdChzdHlsZS5vdmVyZmxvdyArIHN0eWxlLm92ZXJmbG93WSlcclxuICAgICAgICB8fCBwYXJlbnQudGFnTmFtZSA9PT0gJ0JPRFknKSByZXR1cm4gcGFyZW50O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBUYXJnZXQgTm9kZSB0byBzY3JvbGwgdG8uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gaWQgICAgICAgICAgICAgIFRoZSBnaXZlbiBJRCBvZiB0aGUgbm9kZSwgZWl0aGVyIGEgc3RyaW5nIG9yXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICBhbiBlbGVtZW50IHJlZmVyZW5jZVxyXG4gICAqIEBwYXJhbSBhbGxvd0JvZHlUYWcgICAgSW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhlIERvY3VtZW50IEJvZHkgaXNcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNpZGVyZWQgYSB2YWxpZCBUYXJnZXQgTm9kZVxyXG4gICAqIEByZXR1cm5zICAgICAgICAgICAgICAgVGhlIFRhcmdldCBOb2RlIHRvIHNjcm9sbCB0b1xyXG4gICAqL1xyXG4gIHByaXZhdGUgX2dldE5vZGUoaWQ6IFNjcm9sbFRvVGFyZ2V0LCBhbGxvd0JvZHlUYWc6IGJvb2xlYW4gPSBmYWxzZSk6IEhUTUxFbGVtZW50IHtcclxuXHJcbiAgICBsZXQgdGFyZ2V0Tm9kZTogSFRNTEVsZW1lbnQ7XHJcblxyXG4gICAgaWYgKGlzU3RyaW5nKGlkKSkge1xyXG4gICAgICBpZiAoYWxsb3dCb2R5VGFnICYmIChpZCA9PT0gJ2JvZHknIHx8IGlkID09PSAnQk9EWScpKSB7XHJcbiAgICAgICAgdGFyZ2V0Tm9kZSA9IHRoaXMuX2RvY3VtZW50LmJvZHk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGFyZ2V0Tm9kZSA9IHRoaXMuX2RvY3VtZW50LmdldEVsZW1lbnRCeUlkKHN0cmlwSGFzaChpZCkpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlkKSkge1xyXG4gICAgICB0YXJnZXROb2RlID0gdGhpcy5fZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoU3RyaW5nKGlkKSk7XHJcbiAgICB9IGVsc2UgaWYgKGlzRWxlbWVudFJlZihpZCkpIHtcclxuICAgICAgdGFyZ2V0Tm9kZSA9IGlkLm5hdGl2ZUVsZW1lbnQ7XHJcbiAgICB9IGVsc2UgaWYgKGlzTmF0aXZlRWxlbWVudChpZCkpIHtcclxuICAgICAgdGFyZ2V0Tm9kZSA9IGlkO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0YXJnZXROb2RlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0cmlldmUgdGhlIExpc3RlbmVyIHRhcmdldC4gVGhpcyBMaXN0ZW5lciBUYXJnZXQgaXMgdXNlZFxyXG4gICAqIHRvIGF0dGFjaCBFdmVudCBMaXN0ZW5lcnMgb24uIEluIGNhc2Ugb2YgdGhlIHRhcmdldCBiZWluZ1xyXG4gICAqIHRoZSBEb2N1bWVudCBCb2R5LCB3ZSBuZWVkIHRoZSBhY3R1YWwgYHdpbmRvd2AgdG8gbGlzdGVuXHJcbiAgICogZm9yIGV2ZW50cy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBjb250YWluZXIgICAgICAgICAgIFRoZSBIVE1MIENvbnRhaW5lciBlbGVtZW50XHJcbiAgICogQHJldHVybnMgICAgICAgICAgICAgICAgICAgVGhlIExpc3RlbmVyIFRhcmdldCB0byBhdHRhY2ggZXZlbnRzIG9uXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfZ2V0TGlzdGVuZXJUYXJnZXQoY29udGFpbmVyOiBIVE1MRWxlbWVudCk6IFNjcm9sbFRvTGlzdGVuZXJUYXJnZXQge1xyXG4gICAgaWYgKCFjb250YWluZXIpIHJldHVybiBudWxsO1xyXG4gICAgcmV0dXJuIHRoaXMuX2lzRG9jdW1lbnRCb2R5KGNvbnRhaW5lcikgPyB3aW5kb3cgOiBjb250YWluZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUZXN0IGlmIGEgZ2l2ZW4gSFRNTCBFbGVtZW50IGlzIHRoZSBEb2N1bWVudCBCb2R5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGVsZW1lbnQgICAgICAgICAgICAgVGhlIGdpdmVuIEhUTUwgRWxlbWVudFxyXG4gICAqIEByZXR1cm5zICAgICAgICAgICAgICAgICAgIFdoZXRoZXIgb3Igbm90IHRoZSBFbGVtZW50IGlzIHRoZVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIERvY3VtZW50IEJvZHkgRWxlbWVudFxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2lzRG9jdW1lbnRCb2R5KGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogZWxlbWVudCBpcyBIVE1MQm9keUVsZW1lbnQge1xyXG4gICAgcmV0dXJuIGVsZW1lbnQudGFnTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnQk9EWSc7XHJcbiAgfVxyXG59XHJcbiJdfQ==