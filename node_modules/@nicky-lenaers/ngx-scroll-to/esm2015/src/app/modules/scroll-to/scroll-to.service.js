/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Injectable, PLATFORM_ID, Inject } from '@angular/core';
import { DOCUMENT } from '@angular/common';
import { isPlatformBrowser } from '@angular/common';
import { ScrollToAnimation } from './scroll-to-animation';
import { stripHash, isString, isNumber, isElementRef, isWindow, DEFAULTS, isNativeElement } from './scroll-to-helpers';
import { ReplaySubject, throwError } from 'rxjs/index';
/**
 * The Scroll To Service handles starting, interrupting
 * and ending the actual Scroll Animation. It provides
 * some utilities to find the proper HTML Element on a
 * given page to setup Event Listeners and calculate
 * distances for the Animation.
 */
export class ScrollToService {
    /**
     * Construct and setup required paratemeters.
     *
     * @param {?} _document         A Reference to the Document
     * @param {?} _platformId       Angular Platform ID
     */
    constructor(_document, _platformId) {
        this._document = _document;
        this._platformId = _platformId;
        this._interruptiveEvents = ['mousewheel', 'DOMMouseScroll', 'touchstart'];
    }
    /**
     * Target an Element to scroll to. Notice that the `TimeOut` decorator
     * ensures the executing to take place in the next Angular lifecycle.
     * This allows for scrolling to elements that are e.g. initially hidden
     * by means of `*ngIf`, but ought to be scrolled to eventually.
     *
     * \@todo type 'any' in Observable should become custom type like 'ScrollToEvent' (base class), see issue comment:
     * 	- https://github.com/nicky-lenaers/ngx-scroll-to/issues/10#issuecomment-317198481
     *
     * @param {?} options         Configuration Object
     * @return {?} Observable
     */
    scrollTo(options) {
        if (!isPlatformBrowser(this._platformId))
            return new ReplaySubject().asObservable();
        return this._start(options);
    }
    /**
     * Start a new Animation.
     *
     * \@todo Emit proper events from subscription
     *
     * @param {?} options         Configuration Object
     * @return {?} Observable
     */
    _start(options) {
        // Merge config with default values
        const /** @type {?} */ mergedConfigOptions = /** @type {?} */ (Object.assign({}, /** @type {?} */ (DEFAULTS), options));
        if (this._animation)
            this._animation.stop();
        const /** @type {?} */ targetNode = this._getNode(mergedConfigOptions.target);
        if (mergedConfigOptions.target && !targetNode)
            return throwError('Unable to find Target Element');
        const /** @type {?} */ container = this._getContainer(mergedConfigOptions, targetNode);
        if (mergedConfigOptions.container && !container)
            return throwError('Unable to find Container Element');
        const /** @type {?} */ listenerTarget = this._getListenerTarget(container) || window;
        let /** @type {?} */ to = container ? container.getBoundingClientRect().top : 0;
        if (targetNode) {
            to = isWindow(listenerTarget) ? targetNode.offsetTop : targetNode.getBoundingClientRect().top;
        }
        // Create Animation
        this._animation = new ScrollToAnimation(container, listenerTarget, isWindow(listenerTarget), to, mergedConfigOptions, isPlatformBrowser(this._platformId));
        const /** @type {?} */ onInterrupt = () => this._animation.stop();
        this._addInterruptiveEventListeners(listenerTarget, onInterrupt);
        // Start Animation
        const /** @type {?} */ animation$ = this._animation.start();
        this._subscribeToAnimation(animation$, listenerTarget, onInterrupt);
        return animation$;
    }
    /**
     * Subscribe to the events emitted from the Scrolling
     * Animation. Events might be used for e.g. unsubscribing
     * once finished.
     *
     * @param {?} animation$              The Animation Observable
     * @param {?} listenerTarget          The Listener Target for events
     * @param {?} onInterrupt             The handler for Interruptive Events
     * @return {?} Void
     */
    _subscribeToAnimation(animation$, listenerTarget, onInterrupt) {
        const /** @type {?} */ subscription = animation$
            .subscribe(() => { }, () => { }, () => {
            this._removeInterruptiveEventListeners(this._interruptiveEvents, listenerTarget, onInterrupt);
            subscription.unsubscribe();
        });
    }
    /**
     * Get the container HTML Element in which
     * the scrolling should happen.
     *
     * @param {?} options         The Merged Configuration Object
     * @param {?} targetNode    the targeted HTMLElement
     * @return {?}
     */
    _getContainer(options, targetNode) {
        let /** @type {?} */ container = null;
        if (options.container) {
            container = this._getNode(options.container, true);
        }
        else if (targetNode) {
            container = this._getFirstScrollableParent(targetNode);
        }
        return container;
    }
    /**
     * Add listeners for the Animation Interruptive Events
     * to the Listener Target.
     *
     * @param {?} listenerTarget    Target to attach the listener on
     * @param {?} handler           Handler for when the listener fires
     * @return {?} Void
     */
    _addInterruptiveEventListeners(listenerTarget, handler) {
        if (!listenerTarget)
            listenerTarget = window;
        this._interruptiveEvents
            .forEach(event => listenerTarget
            .addEventListener(event, handler, this._supportPassive() ? { passive: true } : false));
    }
    /**
     * Feature-detect support for passive event listeners.
     *
     * @return {?} Whether or not passive event listeners are supported
     */
    _supportPassive() {
        let /** @type {?} */ supportsPassive = false;
        try {
            const /** @type {?} */ opts = Object.defineProperty({}, 'passive', {
                get: function () {
                    supportsPassive = true;
                }
            });
            window.addEventListener('testPassive', null, opts);
            window.removeEventListener('testPassive', null, opts);
        }
        catch (/** @type {?} */ e) { }
        return supportsPassive;
    }
    /**
     * Remove listeners for the Animation Interrupt Event from
     * the Listener Target. Specifying the correct handler prevents
     * memory leaks and makes the allocated memory available for
     * Garbage Collection.
     *
     * @param {?} events            List of Interruptive Events to remove
     * @param {?} listenerTarget    Target to attach the listener on
     * @param {?} handler           Handler for when the listener fires
     * @return {?} Void
     */
    _removeInterruptiveEventListeners(events, listenerTarget, handler) {
        if (!listenerTarget)
            listenerTarget = window;
        events.forEach(event => listenerTarget.removeEventListener(event, handler));
    }
    /**
     * Find the first scrollable parent Node of a given
     * Element. The DOM Tree gets searched upwards
     * to find this first scrollable parent. Parents might
     * be ignored by CSS styles applied to the HTML Element.
     *
     * @param {?} nativeElement     The Element to search the DOM Tree upwards from
     * @return {?} The first scrollable parent HTML Element
     */
    _getFirstScrollableParent(nativeElement) {
        let /** @type {?} */ style = window.getComputedStyle(nativeElement);
        const /** @type {?} */ overflowRegex = /(auto|scroll|overlay)/;
        if (style.position === 'fixed')
            return null;
        for (let /** @type {?} */ parent = nativeElement; parent = parent.parentElement; null) {
            style = window.getComputedStyle(parent);
            if (style.position === 'absolute'
                || style.overflow === 'hidden'
                || style.overflowY === 'hidden')
                continue;
            if (overflowRegex.test(style.overflow + style.overflowY)
                || parent.tagName === 'BODY')
                return parent;
        }
        return null;
    }
    /**
     * Get the Target Node to scroll to.
     *
     * @param {?} id              The given ID of the node, either a string or
     *                        an element reference
     * @param {?=} allowBodyTag    Indicate whether or not the Document Body is
     *                        considered a valid Target Node
     * @return {?} The Target Node to scroll to
     */
    _getNode(id, allowBodyTag = false) {
        let /** @type {?} */ targetNode;
        if (isString(id)) {
            if (allowBodyTag && (id === 'body' || id === 'BODY')) {
                targetNode = this._document.body;
            }
            else {
                targetNode = this._document.getElementById(stripHash(id));
            }
        }
        else if (isNumber(id)) {
            targetNode = this._document.getElementById(String(id));
        }
        else if (isElementRef(id)) {
            targetNode = id.nativeElement;
        }
        else if (isNativeElement(id)) {
            targetNode = id;
        }
        return targetNode;
    }
    /**
     * Retrieve the Listener target. This Listener Target is used
     * to attach Event Listeners on. In case of the target being
     * the Document Body, we need the actual `window` to listen
     * for events.
     *
     * @param {?} container           The HTML Container element
     * @return {?} The Listener Target to attach events on
     */
    _getListenerTarget(container) {
        if (!container)
            return null;
        return this._isDocumentBody(container) ? window : container;
    }
    /**
     * Test if a given HTML Element is the Document Body.
     *
     * @param {?} element             The given HTML Element
     * @return {?} Whether or not the Element is the
     *                            Document Body Element
     */
    _isDocumentBody(element) {
        return element.tagName.toUpperCase() === 'BODY';
    }
}
ScrollToService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ScrollToService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
function ScrollToService_tsickle_Closure_declarations() {
    /**
     * The animation that provides the scrolling
     * to happen smoothly over time. Defining it here
     * allows for usage of e.g. `start` and `stop`
     * methods within this Angular Service.
     * @type {?}
     */
    ScrollToService.prototype._animation;
    /**
     * Interruptive Events allow to scrolling animation
     * to be interrupted before it is finished. The list
     * of Interruptive Events represents those.
     * @type {?}
     */
    ScrollToService.prototype._interruptiveEvents;
    /** @type {?} */
    ScrollToService.prototype._document;
    /** @type {?} */
    ScrollToService.prototype._platformId;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2Nyb2xsLXRvLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Abmlja3ktbGVuYWVycy9uZ3gtc2Nyb2xsLXRvLyIsInNvdXJjZXMiOlsic3JjL2FwcC9tb2R1bGVzL3Njcm9sbC10by9zY3JvbGwtdG8uc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2hFLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMzQyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQVFwRCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUMxRCxPQUFPLEVBQ0wsU0FBUyxFQUNULFFBQVEsRUFDUixRQUFRLEVBQ1IsWUFBWSxFQUNaLFFBQVEsRUFDUixRQUFRLEVBQ1IsZUFBZSxFQUNoQixNQUFNLHFCQUFxQixDQUFDO0FBQzdCLE9BQU8sRUFBYyxhQUFhLEVBQUUsVUFBVSxFQUFFLE1BQU0sWUFBWSxDQUFDOzs7Ozs7OztBQVVuRSxNQUFNOzs7Ozs7O0lBdUJKLFlBQzRCLFNBQWMsRUFDWCxXQUFnQjtRQURuQixjQUFTLEdBQVQsU0FBUyxDQUFLO1FBQ1gsZ0JBQVcsR0FBWCxXQUFXLENBQUs7UUFFN0MsSUFBSSxDQUFDLG1CQUFtQixHQUFHLENBQUMsWUFBWSxFQUFFLGdCQUFnQixFQUFFLFlBQVksQ0FBQyxDQUFDO0tBQzNFOzs7Ozs7Ozs7Ozs7O0lBY00sUUFBUSxDQUFDLE9BQThCO1FBRTVDLEVBQUUsQ0FBQyxDQUFDLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQUMsTUFBTSxDQUFDLElBQUksYUFBYSxFQUFFLENBQUMsWUFBWSxFQUFFLENBQUM7UUFFcEYsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFD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LFVBQVU7Ozs7NENBeUJOLE1BQU0sU0FBQyxRQUFROzRDQUNmLE1BQU0sU0FBQyxXQUFXIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgUExBVEZPUk1fSUQsIEluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcbmltcG9ydCB7IGlzUGxhdGZvcm1Ccm93c2VyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuXHJcbmltcG9ydCB7XHJcbiAgU2Nyb2xsVG9Db25maWdPcHRpb25zLFxyXG4gIFNjcm9sbFRvVGFyZ2V0LFxyXG4gIFNjcm9sbFRvTGlzdGVuZXJUYXJnZXQsXHJcbiAgU2Nyb2xsVG9Db25maWdPcHRpb25zVGFyZ2V0XHJcbn0gZnJvbSAnLi9zY3JvbGwtdG8tY29uZmlnLmludGVyZmFjZSc7XHJcbmltcG9ydCB7IFNjcm9sbFRvQW5pbWF0aW9uIH0gZnJvbSAnLi9zY3JvbGwtdG8tYW5pbWF0aW9uJztcclxuaW1wb3J0IHtcclxuICBzdHJpcEhhc2gsXHJcbiAgaXNTdHJpbmcsXHJcbiAgaXNOdW1iZXIsXHJcbiAgaXNFbGVtZW50UmVmLFxyXG4gIGlzV2luZG93LFxyXG4gIERFRkFVTFRTLFxyXG4gIGlzTmF0aXZlRWxlbWVudFxyXG59IGZyb20gJy4vc2Nyb2xsLXRvLWhlbHBlcnMnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBSZXBsYXlTdWJqZWN0LCB0aHJvd0Vycm9yIH0gZnJvbSAncnhqcy9pbmRleCc7XHJcblxyXG4vKipcclxuICogVGhlIFNjcm9sbCBUbyBTZXJ2aWNlIGhhbmRsZXMgc3RhcnRpbmcsIGludGVycnVwdGluZ1xyXG4gKiBhbmQgZW5kaW5nIHRoZSBhY3R1YWwgU2Nyb2xsIEFuaW1hdGlvbi4gSXQgcHJvdmlkZXNcclxuICogc29tZSB1dGlsaXRpZXMgdG8gZmluZCB0aGUgcHJvcGVyIEhUTUwgRWxlbWVudCBvbiBhXHJcbiAqIGdpdmVuIHBhZ2UgdG8gc2V0dXAgRXZlbnQgTGlzdGVuZXJzIGFuZCBjYWxjdWxhdGVcclxuICogZGlzdGFuY2VzIGZvciB0aGUgQW5pbWF0aW9uLlxyXG4gKi9cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgU2Nyb2xsVG9TZXJ2aWNlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGFuaW1hdGlvbiB0aGF0IHByb3ZpZGVzIHRoZSBzY3JvbGxpbmdcclxuICAgKiB0byBoYXBwZW4gc21vb3RobHkgb3ZlciB0aW1lLiBEZWZpbmluZyBpdCBoZXJlXHJcbiAgICogYWxsb3dzIGZvciB1c2FnZSBvZiBlLmcuIGBzdGFydGAgYW5kIGBzdG9wYFxyXG4gICAqIG1ldGhvZHMgd2l0aGluIHRoaXMgQW5ndWxhciBTZXJ2aWNlLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2FuaW1hdGlvbjogU2Nyb2xsVG9BbmltYXRpb247XHJcblxyXG4gIC8qKlxyXG4gICAqIEludGVycnVwdGl2ZSBFdmVudHMgYWxsb3cgdG8gc2Nyb2xsaW5nIGFuaW1hdGlvblxyXG4gICAqIHRvIGJlIGludGVycnVwdGVkIGJlZm9yZSBpdCBpcyBmaW5pc2hlZC4gVGhlIGxpc3RcclxuICAgKiBvZiBJbnRlcnJ1cHRpdmUgRXZlbnRzIHJlcHJlc2VudHMgdGhvc2UuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfaW50ZXJydXB0aXZlRXZlbnRzOiBzdHJpbmdbXTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RydWN0IGFuZCBzZXR1cCByZXF1aXJlZCBwYXJhdGVtZXRlcnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gX2RvY3VtZW50ICAgICAgICAgQSBSZWZlcmVuY2UgdG8gdGhlIERvY3VtZW50XHJcbiAgICogQHBhcmFtIF9wbGF0Zm9ybUlkICAgICAgIEFuZ3VsYXIgUGxhdGZvcm0gSURcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIEBJbmplY3QoRE9DVU1FTlQpIHByaXZhdGUgX2RvY3VtZW50OiBhbnksXHJcbiAgICBASW5qZWN0KFBMQVRGT1JNX0lEKSBwcml2YXRlIF9wbGF0Zm9ybUlkOiBhbnlcclxuICApIHtcclxuICAgIHRoaXMuX2ludGVycnVwdGl2ZUV2ZW50cyA9IFsnbW91c2V3aGVlbCcsICdET01Nb3VzZVNjcm9sbCcsICd0b3VjaHN0YXJ0J107XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUYXJnZXQgYW4gRWxlbWVudCB0byBzY3JvbGwgdG8uIE5vdGljZSB0aGF0IHRoZSBgVGltZU91dGAgZGVjb3JhdG9yXHJcbiAgICogZW5zdXJlcyB0aGUgZXhlY3V0aW5nIHRvIHRha2UgcGxhY2UgaW4gdGhlIG5leHQgQW5ndWxhciBsaWZlY3ljbGUuXHJcbiAgICogVGhpcyBhbGxvd3MgZm9yIHNjcm9sbGluZyB0byBlbGVtZW50cyB0aGF0IGFyZSBlLmcuIGluaXRpYWxseSBoaWRkZW5cclxuICAgKiBieSBtZWFucyBvZiBgKm5nSWZgLCBidXQgb3VnaHQgdG8gYmUgc2Nyb2xsZWQgdG8gZXZlbnR1YWxseS5cclxuICAgKlxyXG4gICAqIEB0b2RvIHR5cGUgJ2FueScgaW4gT2JzZXJ2YWJsZSBzaG91bGQgYmVjb21lIGN1c3RvbSB0eXBlIGxpa2UgJ1Njcm9sbFRvRXZlbnQnIChiYXNlIGNsYXNzKSwgc2VlIGlzc3VlIGNvbW1lbnQ6XHJcbiAgICogXHQtIGh0dHBzOi8vZ2l0aHViLmNvbS9uaWNreS1sZW5hZXJzL25neC1zY3JvbGwtdG8vaXNzdWVzLzEwI2lzc3VlY29tbWVudC0zMTcxOTg0ODFcclxuICAgKlxyXG4gICAqIEBwYXJhbSBvcHRpb25zICAgICAgICAgQ29uZmlndXJhdGlvbiBPYmplY3RcclxuICAgKiBAcmV0dXJucyAgICAgICAgICAgICAgIE9ic2VydmFibGVcclxuICAgKi9cclxuICBwdWJsaWMgc2Nyb2xsVG8ob3B0aW9uczogU2Nyb2xsVG9Db25maWdPcHRpb25zKTogT2JzZXJ2YWJsZTxhbnk+IHtcclxuXHJcbiAgICBpZiAoIWlzUGxhdGZvcm1Ccm93c2VyKHRoaXMuX3BsYXRmb3JtSWQpKSByZXR1cm4gbmV3IFJlcGxheVN1YmplY3QoKS5hc09ic2VydmFibGUoKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5fc3RhcnQob3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGFydCBhIG5ldyBBbmltYXRpb24uXHJcbiAgICpcclxuICAgKiBAdG9kbyBFbWl0IHByb3BlciBldmVudHMgZnJvbSBzdWJzY3JpcHRpb25cclxuICAgKlxyXG4gICAqIEBwYXJhbSBvcHRpb25zICAgICAgICAgQ29uZmlndXJhdGlvbiBPYmplY3RcclxuICAgKiBAcmV0dXJucyAgICAgICAgICAgICAgIE9ic2VydmFibGVcclxuICAgKi9cclxuICBwcml2YXRlIF9zdGFydChvcHRpb25zOiBTY3JvbGxUb0NvbmZpZ09wdGlvbnMpOiBPYnNlcnZhYmxlPG51bWJlcj4ge1xyXG5cclxuICAgIC8vIE1lcmdlIGNvbmZpZyB3aXRoIGRlZmF1bHQgdmFsdWVzXHJcbiAgICBjb25zdCBtZXJnZWRDb25maWdPcHRpb25zID0ge1xyXG4gICAgICAuLi5ERUZBVUxUUyBhcyBTY3JvbGxUb0NvbmZpZ09wdGlvbnMsXHJcbiAgICAgIC4uLm9wdGlvbnNcclxuICAgIH0gYXMgU2Nyb2xsVG9Db25maWdPcHRpb25zVGFyZ2V0O1xyXG5cclxuICAgIGlmICh0aGlzLl9hbmltYXRpb24pIHRoaXMuX2FuaW1hdGlvbi5zdG9wKCk7XHJcblxyXG4gICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHRoaXMuX2dldE5vZGUobWVyZ2VkQ29uZmlnT3B0aW9ucy50YXJnZXQpO1xyXG4gICAgaWYgKG1lcmdlZENvbmZpZ09wdGlvbnMudGFyZ2V0ICYmICF0YXJnZXROb2RlKSByZXR1cm4gdGhyb3dFcnJvcignVW5hYmxlIHRvIGZpbmQgVGFyZ2V0IEVsZW1lbnQnKTtcclxuXHJcbiAgICBjb25zdCBjb250YWluZXI6IEhUTUxFbGVtZW50ID0gdGhpcy5fZ2V0Q29udGFpbmVyKG1lcmdlZENvbmZpZ09wdGlvbnMsIHRhcmdldE5vZGUpO1xyXG4gICAgaWYgKG1lcmdlZENvbmZpZ09wdGlvbnMuY29udGFpbmVyICYmICFjb250YWluZXIpIHJldHVybiB0aHJvd0Vycm9yKCdVbmFibGUgdG8gZmluZCBDb250YWluZXIgRWxlbWVudCcpO1xyXG5cclxuICAgIGNvbnN0IGxpc3RlbmVyVGFyZ2V0ID0gdGhpcy5fZ2V0TGlzdGVuZXJUYXJnZXQoY29udGFpbmVyKSB8fCB3aW5kb3c7XHJcblxyXG4gICAgbGV0IHRvID0gY29udGFpbmVyID8gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCA6IDA7XHJcblxyXG4gICAgaWYgKHRhcmdldE5vZGUpIHtcclxuICAgICAgdG8gPSBpc1dpbmRvdyhsaXN0ZW5lclRhcmdldCkgPyB0YXJnZXROb2RlLm9mZnNldFRvcCA6IHRhcmdldE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENyZWF0ZSBBbmltYXRpb25cclxuICAgIHRoaXMuX2FuaW1hdGlvbiA9IG5ldyBTY3JvbGxUb0FuaW1hdGlvbihcclxuICAgICAgY29udGFpbmVyLFxyXG4gICAgICBsaXN0ZW5lclRhcmdldCxcclxuICAgICAgaXNXaW5kb3cobGlzdGVuZXJUYXJnZXQpLFxyXG4gICAgICB0byxcclxuICAgICAgbWVyZ2VkQ29uZmlnT3B0aW9ucyxcclxuICAgICAgaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5fcGxhdGZvcm1JZClcclxuICAgICk7XHJcbiAgICBjb25zdCBvbkludGVycnVwdCA9ICgpID0+IHRoaXMuX2FuaW1hdGlvbi5zdG9wKCk7XHJcbiAgICB0aGlzLl9hZGRJbnRlcnJ1cHRpdmVFdmVudExpc3RlbmVycyhsaXN0ZW5lclRhcmdldCwgb25JbnRlcnJ1cHQpO1xyXG5cclxuICAgIC8vIFN0YXJ0IEFuaW1hdGlvblxyXG4gICAgY29uc3QgYW5pbWF0aW9uJCA9IHRoaXMuX2FuaW1hdGlvbi5zdGFydCgpO1xyXG4gICAgdGhpcy5fc3Vic2NyaWJlVG9BbmltYXRpb24oYW5pbWF0aW9uJCwgbGlzdGVuZXJUYXJnZXQsIG9uSW50ZXJydXB0KTtcclxuXHJcbiAgICByZXR1cm4gYW5pbWF0aW9uJDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN1YnNjcmliZSB0byB0aGUgZXZlbnRzIGVtaXR0ZWQgZnJvbSB0aGUgU2Nyb2xsaW5nXHJcbiAgICogQW5pbWF0aW9uLiBFdmVudHMgbWlnaHQgYmUgdXNlZCBmb3IgZS5nLiB1bnN1YnNjcmliaW5nXHJcbiAgICogb25jZSBmaW5pc2hlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBhbmltYXRpb24kICAgICAgICAgICAgICBUaGUgQW5pbWF0aW9uIE9ic2VydmFibGVcclxuICAgKiBAcGFyYW0gbGlzdGVuZXJUYXJnZXQgICAgICAgICAgVGhlIExpc3RlbmVyIFRhcmdldCBmb3IgZXZlbnRzXHJcbiAgICogQHBhcmFtIG9uSW50ZXJydXB0ICAgICAgICAgICAgIFRoZSBoYW5kbGVyIGZvciBJbnRlcnJ1cHRpdmUgRXZlbnRzXHJcbiAgICogQHJldHVybnMgICAgICAgICAgICAgICAgICAgICAgIFZvaWRcclxuICAgKi9cclxuICBwcml2YXRlIF9zdWJzY3JpYmVUb0FuaW1hdGlvbihcclxuICAgIGFuaW1hdGlvbiQ6IE9ic2VydmFibGU8YW55PixcclxuICAgIGxpc3RlbmVyVGFyZ2V0OiBTY3JvbGxUb0xpc3RlbmVyVGFyZ2V0LFxyXG4gICAgb25JbnRlcnJ1cHQ6IEV2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3RcclxuICApIHtcclxuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGFuaW1hdGlvbiRcclxuICAgICAgLnN1YnNjcmliZShcclxuICAgICAgICAoKSA9PiB7IH0sXHJcbiAgICAgICAgKCkgPT4geyB9LFxyXG4gICAgICAgICgpID0+IHtcclxuICAgICAgICAgIHRoaXMuX3JlbW92ZUludGVycnVwdGl2ZUV2ZW50TGlzdGVuZXJzKHRoaXMuX2ludGVycnVwdGl2ZUV2ZW50cywgbGlzdGVuZXJUYXJnZXQsIG9uSW50ZXJydXB0KTtcclxuICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgY29udGFpbmVyIEhUTUwgRWxlbWVudCBpbiB3aGljaFxyXG4gICAqIHRoZSBzY3JvbGxpbmcgc2hvdWxkIGhhcHBlbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBvcHRpb25zICAgICAgICAgVGhlIE1lcmdlZCBDb25maWd1cmF0aW9uIE9iamVjdFxyXG4gICAqIEBwYXJhbSB0YXJnZXROb2RlICAgIHRoZSB0YXJnZXRlZCBIVE1MRWxlbWVudFxyXG4gICAqIEByZXR1cm5zXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfZ2V0Q29udGFpbmVyKG9wdGlvbnM6IFNjcm9sbFRvQ29uZmlnT3B0aW9ucywgdGFyZ2V0Tm9kZTogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudCB8IG51bGwge1xyXG5cclxuICAgIGxldCBjb250YWluZXI6IEhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGw7XHJcblxyXG4gICAgaWYgKG9wdGlvbnMuY29udGFpbmVyKSB7XHJcbiAgICAgIGNvbnRhaW5lciA9IHRoaXMuX2dldE5vZGUob3B0aW9ucy5jb250YWluZXIsIHRydWUpO1xyXG4gICAgfSBlbHNlIGlmICh0YXJnZXROb2RlKSB7XHJcbiAgICAgIGNvbnRhaW5lciA9IHRoaXMuX2dldEZpcnN0U2Nyb2xsYWJsZVBhcmVudCh0YXJnZXROb2RlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY29udGFpbmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGxpc3RlbmVycyBmb3IgdGhlIEFuaW1hdGlvbiBJbnRlcnJ1cHRpdmUgRXZlbnRzXHJcbiAgICogdG8gdGhlIExpc3RlbmVyIFRhcmdldC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBldmVudHMgICAgICAgICAgICBMaXN0IG9mIGV2ZW50cyB0byBsaXN0ZW4gdG9cclxuICAgKiBAcGFyYW0gbGlzdGVuZXJUYXJnZXQgICAgVGFyZ2V0IHRvIGF0dGFjaCB0aGUgbGlzdGVuZXIgb25cclxuICAgKiBAcGFyYW0gaGFuZGxlciAgICAgICAgICAgSGFuZGxlciBmb3Igd2hlbiB0aGUgbGlzdGVuZXIgZmlyZXNcclxuICAgKiBAcmV0dXJucyAgICAgICAgICAgICAgICAgVm9pZFxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2FkZEludGVycnVwdGl2ZUV2ZW50TGlzdGVuZXJzKFxyXG4gICAgbGlzdGVuZXJUYXJnZXQ6IFNjcm9sbFRvTGlzdGVuZXJUYXJnZXQsXHJcbiAgICBoYW5kbGVyOiBFdmVudExpc3RlbmVyT3JFdmVudExpc3RlbmVyT2JqZWN0KTogdm9pZCB7XHJcblxyXG4gICAgaWYgKCFsaXN0ZW5lclRhcmdldCkgbGlzdGVuZXJUYXJnZXQgPSB3aW5kb3c7XHJcblxyXG4gICAgdGhpcy5faW50ZXJydXB0aXZlRXZlbnRzXHJcbiAgICAgIC5mb3JFYWNoKGV2ZW50ID0+IGxpc3RlbmVyVGFyZ2V0XHJcbiAgICAgICAgLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIHRoaXMuX3N1cHBvcnRQYXNzaXZlKCkgPyB7IHBhc3NpdmU6IHRydWUgfSA6IGZhbHNlKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGZWF0dXJlLWRldGVjdCBzdXBwb3J0IGZvciBwYXNzaXZlIGV2ZW50IGxpc3RlbmVycy5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zICAgICAgIFdoZXRoZXIgb3Igbm90IHBhc3NpdmUgZXZlbnQgbGlzdGVuZXJzIGFyZSBzdXBwb3J0ZWRcclxuICAgKi9cclxuICBwcml2YXRlIF9zdXBwb3J0UGFzc2l2ZSgpOiBib29sZWFuIHtcclxuXHJcbiAgICBsZXQgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgb3B0cyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0UGFzc2l2ZScsIG51bGwsIG9wdHMpO1xyXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdFBhc3NpdmUnLCBudWxsLCBvcHRzKTtcclxuICAgIH0gY2F0Y2ggKGUpIHsgfVxyXG5cclxuICAgIHJldHVybiBzdXBwb3J0c1Bhc3NpdmU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmUgbGlzdGVuZXJzIGZvciB0aGUgQW5pbWF0aW9uIEludGVycnVwdCBFdmVudCBmcm9tXHJcbiAgICogdGhlIExpc3RlbmVyIFRhcmdldC4gU3BlY2lmeWluZyB0aGUgY29ycmVjdCBoYW5kbGVyIHByZXZlbnRzXHJcbiAgICogbWVtb3J5IGxlYWtzIGFuZCBtYWtlcyB0aGUgYWxsb2NhdGVkIG1lbW9yeSBhdmFpbGFibGUgZm9yXHJcbiAgICogR2FyYmFnZSBDb2xsZWN0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGV2ZW50cyAgICAgICAgICAgIExpc3Qgb2YgSW50ZXJydXB0aXZlIEV2ZW50cyB0byByZW1vdmVcclxuICAgKiBAcGFyYW0gbGlzdGVuZXJUYXJnZXQgICAgVGFyZ2V0IHRvIGF0dGFjaCB0aGUgbGlzdGVuZXIgb25cclxuICAgKiBAcGFyYW0gaGFuZGxlciAgICAgICAgICAgSGFuZGxlciBmb3Igd2hlbiB0aGUgbGlzdGVuZXIgZmlyZXNcclxuICAgKiBAcmV0dXJucyAgICAgICAgICAgICAgICAgVm9pZFxyXG4gICAqL1xyXG4gIHByaXZhdGUgX3JlbW92ZUludGVycnVwdGl2ZUV2ZW50TGlzdGVuZXJzKFxyXG4gICAgZXZlbnRzOiBzdHJpbmdbXSxcclxuICAgIGxpc3RlbmVyVGFyZ2V0OiBTY3JvbGxUb0xpc3RlbmVyVGFyZ2V0LFxyXG4gICAgaGFuZGxlcjogRXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdCk6IHZvaWQge1xyXG5cclxuICAgIGlmICghbGlzdGVuZXJUYXJnZXQpIGxpc3RlbmVyVGFyZ2V0ID0gd2luZG93O1xyXG4gICAgZXZlbnRzLmZvckVhY2goZXZlbnQgPT4gbGlzdGVuZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcikpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmluZCB0aGUgZmlyc3Qgc2Nyb2xsYWJsZSBwYXJlbnQgTm9kZSBvZiBhIGdpdmVuXHJcbiAgICogRWxlbWVudC4gVGhlIERPTSBUcmVlIGdldHMgc2VhcmNoZWQgdXB3YXJkc1xyXG4gICAqIHRvIGZpbmQgdGhpcyBmaXJzdCBzY3JvbGxhYmxlIHBhcmVudC4gUGFyZW50cyBtaWdodFxyXG4gICAqIGJlIGlnbm9yZWQgYnkgQ1NTIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBIVE1MIEVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gbmF0aXZlRWxlbWVudCAgICAgVGhlIEVsZW1lbnQgdG8gc2VhcmNoIHRoZSBET00gVHJlZSB1cHdhcmRzIGZyb21cclxuICAgKiBAcmV0dXJucyAgICAgICAgICAgICAgICAgVGhlIGZpcnN0IHNjcm9sbGFibGUgcGFyZW50IEhUTUwgRWxlbWVudFxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2dldEZpcnN0U2Nyb2xsYWJsZVBhcmVudChuYXRpdmVFbGVtZW50OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50IHtcclxuXHJcbiAgICBsZXQgc3R5bGU6IENTU1N0eWxlRGVjbGFyYXRpb24gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShuYXRpdmVFbGVtZW50KTtcclxuXHJcbiAgICBjb25zdCBvdmVyZmxvd1JlZ2V4OiBSZWdFeHAgPSAvKGF1dG98c2Nyb2xsfG92ZXJsYXkpLztcclxuXHJcbiAgICBpZiAoc3R5bGUucG9zaXRpb24gPT09ICdmaXhlZCcpIHJldHVybiBudWxsO1xyXG5cclxuICAgIGZvciAobGV0IHBhcmVudCA9IG5hdGl2ZUVsZW1lbnQ7IHBhcmVudCA9IHBhcmVudC5wYXJlbnRFbGVtZW50OyBudWxsKSB7XHJcblxyXG4gICAgICBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHBhcmVudCk7XHJcblxyXG4gICAgICBpZiAoc3R5bGUucG9zaXRpb24gPT09ICdhYnNvbHV0ZSdcclxuICAgICAgICB8fCBzdHlsZS5vdmVyZmxvdyA9PT0gJ2hpZGRlbidcclxuICAgICAgICB8fCBzdHlsZS5vdmVyZmxvd1kgPT09ICdoaWRkZW4nKSBjb250aW51ZTtcclxuXHJcbiAgICAgIGlmIChvdmVyZmxvd1JlZ2V4LnRlc3Qoc3R5bGUub3ZlcmZsb3cgKyBzdHlsZS5vdmVyZmxvd1kpXHJcbiAgICAgICAgfHwgcGFyZW50LnRhZ05hbWUgPT09ICdCT0RZJykgcmV0dXJuIHBhcmVudDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgVGFyZ2V0IE5vZGUgdG8gc2Nyb2xsIHRvLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGlkICAgICAgICAgICAgICBUaGUgZ2l2ZW4gSUQgb2YgdGhlIG5vZGUsIGVpdGhlciBhIHN0cmluZyBvclxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgYW4gZWxlbWVudCByZWZlcmVuY2VcclxuICAgKiBAcGFyYW0gYWxsb3dCb2R5VGFnICAgIEluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoZSBEb2N1bWVudCBCb2R5IGlzXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICBjb25zaWRlcmVkIGEgdmFsaWQgVGFyZ2V0IE5vZGVcclxuICAgKiBAcmV0dXJucyAgICAgICAgICAgICAgIFRoZSBUYXJnZXQgTm9kZSB0byBzY3JvbGwgdG9cclxuICAgKi9cclxuICBwcml2YXRlIF9nZXROb2RlKGlkOiBTY3JvbGxUb1RhcmdldCwgYWxsb3dCb2R5VGFnOiBib29sZWFuID0gZmFsc2UpOiBIVE1MRWxlbWVudCB7XHJcblxyXG4gICAgbGV0IHRhcmdldE5vZGU6IEhUTUxFbGVtZW50O1xyXG5cclxuICAgIGlmIChpc1N0cmluZyhpZCkpIHtcclxuICAgICAgaWYgKGFsbG93Qm9keVRhZyAmJiAoaWQgPT09ICdib2R5JyB8fCBpZCA9PT0gJ0JPRFknKSkge1xyXG4gICAgICAgIHRhcmdldE5vZGUgPSB0aGlzLl9kb2N1bWVudC5ib2R5O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRhcmdldE5vZGUgPSB0aGlzLl9kb2N1bWVudC5nZXRFbGVtZW50QnlJZChzdHJpcEhhc2goaWQpKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChpc051bWJlcihpZCkpIHtcclxuICAgICAgdGFyZ2V0Tm9kZSA9IHRoaXMuX2RvY3VtZW50LmdldEVsZW1lbnRCeUlkKFN0cmluZyhpZCkpO1xyXG4gICAgfSBlbHNlIGlmIChpc0VsZW1lbnRSZWYoaWQpKSB7XHJcbiAgICAgIHRhcmdldE5vZGUgPSBpZC5uYXRpdmVFbGVtZW50O1xyXG4gICAgfSBlbHNlIGlmIChpc05hdGl2ZUVsZW1lbnQoaWQpKSB7XHJcbiAgICAgIHRhcmdldE5vZGUgPSBpZDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGFyZ2V0Tm9kZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHJpZXZlIHRoZSBMaXN0ZW5lciB0YXJnZXQuIFRoaXMgTGlzdGVuZXIgVGFyZ2V0IGlzIHVzZWRcclxuICAgKiB0byBhdHRhY2ggRXZlbnQgTGlzdGVuZXJzIG9uLiBJbiBjYXNlIG9mIHRoZSB0YXJnZXQgYmVpbmdcclxuICAgKiB0aGUgRG9jdW1lbnQgQm9keSwgd2UgbmVlZCB0aGUgYWN0dWFsIGB3aW5kb3dgIHRvIGxpc3RlblxyXG4gICAqIGZvciBldmVudHMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gY29udGFpbmVyICAgICAgICAgICBUaGUgSFRNTCBDb250YWluZXIgZWxlbWVudFxyXG4gICAqIEByZXR1cm5zICAgICAgICAgICAgICAgICAgIFRoZSBMaXN0ZW5lciBUYXJnZXQgdG8gYXR0YWNoIGV2ZW50cyBvblxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2dldExpc3RlbmVyVGFyZ2V0KGNvbnRhaW5lcjogSFRNTEVsZW1lbnQpOiBTY3JvbGxUb0xpc3RlbmVyVGFyZ2V0IHtcclxuICAgIGlmICghY29udGFpbmVyKSByZXR1cm4gbnVsbDtcclxuICAgIHJldHVybiB0aGlzLl9pc0RvY3VtZW50Qm9keShjb250YWluZXIpID8gd2luZG93IDogY29udGFpbmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGVzdCBpZiBhIGdpdmVuIEhUTUwgRWxlbWVudCBpcyB0aGUgRG9jdW1lbnQgQm9keS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBlbGVtZW50ICAgICAgICAgICAgIFRoZSBnaXZlbiBIVE1MIEVsZW1lbnRcclxuICAgKiBAcmV0dXJucyAgICAgICAgICAgICAgICAgICBXaGV0aGVyIG9yIG5vdCB0aGUgRWxlbWVudCBpcyB0aGVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBEb2N1bWVudCBCb2R5IEVsZW1lbnRcclxuICAgKi9cclxuICBwcml2YXRlIF9pc0RvY3VtZW50Qm9keShlbGVtZW50OiBIVE1MRWxlbWVudCk6IGVsZW1lbnQgaXMgSFRNTEJvZHlFbGVtZW50IHtcclxuICAgIHJldHVybiBlbGVtZW50LnRhZ05hbWUudG9VcHBlckNhc2UoKSA9PT0gJ0JPRFknO1xyXG4gIH1cclxufVxyXG4iXX0=